// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb/download.proto

package pb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DownloadStatus 表示下载任务的状态
type DownloadStatus int32

const (
	// 未指定状态，表示任务状态未初始化或未知
	DownloadStatus_DOWNLOAD_STATUS_UNSPECIFIED DownloadStatus = 0
	// 获取文件信息中，表示正在向网络请求文件的元数据信息（如名称、大小、格式等）
	DownloadStatus_DOWNLOAD_STATUS_FETCHING_INFO DownloadStatus = 1
	// 待下载，任务已创建但尚未开始执行，等待系统调度
	DownloadStatus_DOWNLOAD_STATUS_PENDING DownloadStatus = 2
	// 下载中，任务正在执行文件下载操作，数据传输进行中
	DownloadStatus_DOWNLOAD_STATUS_DOWNLOADING DownloadStatus = 3
	// 已暂停，任务已被用户或系统暂停，可通过恢复操作继续执行
	DownloadStatus_DOWNLOAD_STATUS_PAUSED DownloadStatus = 4
	// 已完成，任务已成功完成所有下载操作，文件已全部传输到目标位置
	DownloadStatus_DOWNLOAD_STATUS_COMPLETED DownloadStatus = 5
	// 失败，任务由于网络问题、存储错误等原因未能成功完成
	DownloadStatus_DOWNLOAD_STATUS_FAILED DownloadStatus = 6
	// 已取消，任务被用户或系统主动取消，不再继续执行
	DownloadStatus_DOWNLOAD_STATUS_CANCELLED DownloadStatus = 7
)

var DownloadStatus_name = map[int32]string{
	0: "DOWNLOAD_STATUS_UNSPECIFIED",
	1: "DOWNLOAD_STATUS_FETCHING_INFO",
	2: "DOWNLOAD_STATUS_PENDING",
	3: "DOWNLOAD_STATUS_DOWNLOADING",
	4: "DOWNLOAD_STATUS_PAUSED",
	5: "DOWNLOAD_STATUS_COMPLETED",
	6: "DOWNLOAD_STATUS_FAILED",
	7: "DOWNLOAD_STATUS_CANCELLED",
}

var DownloadStatus_value = map[string]int32{
	"DOWNLOAD_STATUS_UNSPECIFIED":   0,
	"DOWNLOAD_STATUS_FETCHING_INFO": 1,
	"DOWNLOAD_STATUS_PENDING":       2,
	"DOWNLOAD_STATUS_DOWNLOADING":   3,
	"DOWNLOAD_STATUS_PAUSED":        4,
	"DOWNLOAD_STATUS_COMPLETED":     5,
	"DOWNLOAD_STATUS_FAILED":        6,
	"DOWNLOAD_STATUS_CANCELLED":     7,
}

func (x DownloadStatus) String() string {
	return proto.EnumName(DownloadStatus_name, int32(x))
}

func (DownloadStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_01c5336762b2111d, []int{0}
}

// SegmentDownloadStatus 表示文件片段的下载状态
type SegmentDownloadStatus int32

const (
	// 未指定状态，表示片段状态未初始化或未知
	SegmentDownloadStatus_SEGMENT_DOWNLOAD_STATUS_UNSPECIFIED SegmentDownloadStatus = 0
	// 待下载，文件片段已准备好待下载但尚未开始传输
	SegmentDownloadStatus_SEGMENT_DOWNLOAD_STATUS_PENDING SegmentDownloadStatus = 1
	// 下载中，文件片段正在下载过程中，数据正在传输
	SegmentDownloadStatus_SEGMENT_DOWNLOAD_STATUS_DOWNLOADING SegmentDownloadStatus = 2
	// 已完成，文件片段已成功下载并通过完整性校验
	SegmentDownloadStatus_SEGMENT_DOWNLOAD_STATUS_COMPLETED SegmentDownloadStatus = 3
	// 失败，文件片段下载失败，可能是由于网络问题或服务器错误
	SegmentDownloadStatus_SEGMENT_DOWNLOAD_STATUS_FAILED SegmentDownloadStatus = 4
)

var SegmentDownloadStatus_name = map[int32]string{
	0: "SEGMENT_DOWNLOAD_STATUS_UNSPECIFIED",
	1: "SEGMENT_DOWNLOAD_STATUS_PENDING",
	2: "SEGMENT_DOWNLOAD_STATUS_DOWNLOADING",
	3: "SEGMENT_DOWNLOAD_STATUS_COMPLETED",
	4: "SEGMENT_DOWNLOAD_STATUS_FAILED",
}

var SegmentDownloadStatus_value = map[string]int32{
	"SEGMENT_DOWNLOAD_STATUS_UNSPECIFIED": 0,
	"SEGMENT_DOWNLOAD_STATUS_PENDING":     1,
	"SEGMENT_DOWNLOAD_STATUS_DOWNLOADING": 2,
	"SEGMENT_DOWNLOAD_STATUS_COMPLETED":   3,
	"SEGMENT_DOWNLOAD_STATUS_FAILED":      4,
}

func (x SegmentDownloadStatus) String() string {
	return proto.EnumName(SegmentDownloadStatus_name, int32(x))
}

func (SegmentDownloadStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_01c5336762b2111d, []int{1}
}

// DownloadFileRecord 包含待下载文件的详细信息及其分片信息
type DownloadFileRecord struct {
	// 任务唯一标识，用于在系统中唯一识别该下载任务
	// @gotags: badgerhold:"key"
	TaskId string `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty" badgerhold:"key"`
	// 文件唯一标识，用于在系统内部唯一区分文件，通常是哈希值或UUID
	FileId string `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	// 所有者的公钥哈希，用于身份验证和访问控制
	PubkeyHash []byte `protobuf:"bytes,3,opt,name=pubkey_hash,json=pubkeyHash,proto3" json:"pubkey_hash,omitempty"`
	// 恢复密钥的第一个分片，用于密钥重建
	FirstKeyShare []byte `protobuf:"bytes,4,opt,name=first_key_share,json=firstKeyShare,proto3" json:"first_key_share,omitempty"`
	// 文件的临时存储位置，用于存储下载过程中的临时文件
	TempStorage string `protobuf:"bytes,5,opt,name=temp_storage,json=tempStorage,proto3" json:"temp_storage,omitempty"`
	// 文件的元数据，如文件名、大小、类型等基本信息
	FileMeta *FileMeta `protobuf:"bytes,6,opt,name=file_meta,json=fileMeta,proto3" json:"file_meta,omitempty"`
	// 文件片段的哈希表，记录每个片段的哈希值，支持纠错和数据完整性验证
	SliceTable map[int64]*HashTable `protobuf:"bytes,7,rep,name=slice_table,json=sliceTable,proto3" json:"slice_table,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// 文件下载的开始时间戳，记录任务开始执行的时间点
	StartedAt int64 `protobuf:"varint,8,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	// 文件下载的完成时间戳，记录任务完成执行的时间点
	FinishedAt int64 `protobuf:"varint,9,opt,name=finished_at,json=finishedAt,proto3" json:"finished_at,omitempty"`
	// 下载任务的当前状态，如pending、downloading、completed等
	// @gotags: badgerhold:"index"
	Status               DownloadStatus `protobuf:"varint,10,opt,name=status,proto3,enum=pb.DownloadStatus" json:"status,omitempty" badgerhold:"index"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *DownloadFileRecord) Reset()         { *m = DownloadFileRecord{} }
func (m *DownloadFileRecord) String() string { return proto.CompactTextString(m) }
func (*DownloadFileRecord) ProtoMessage()    {}
func (*DownloadFileRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_01c5336762b2111d, []int{0}
}
func (m *DownloadFileRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadFileRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadFileRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadFileRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadFileRecord.Merge(m, src)
}
func (m *DownloadFileRecord) XXX_Size() int {
	return m.Size()
}
func (m *DownloadFileRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadFileRecord.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadFileRecord proto.InternalMessageInfo

func (m *DownloadFileRecord) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *DownloadFileRecord) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *DownloadFileRecord) GetPubkeyHash() []byte {
	if m != nil {
		return m.PubkeyHash
	}
	return nil
}

func (m *DownloadFileRecord) GetFirstKeyShare() []byte {
	if m != nil {
		return m.FirstKeyShare
	}
	return nil
}

func (m *DownloadFileRecord) GetTempStorage() string {
	if m != nil {
		return m.TempStorage
	}
	return ""
}

func (m *DownloadFileRecord) GetFileMeta() *FileMeta {
	if m != nil {
		return m.FileMeta
	}
	return nil
}

func (m *DownloadFileRecord) GetSliceTable() map[int64]*HashTable {
	if m != nil {
		return m.SliceTable
	}
	return nil
}

func (m *DownloadFileRecord) GetStartedAt() int64 {
	if m != nil {
		return m.StartedAt
	}
	return 0
}

func (m *DownloadFileRecord) GetFinishedAt() int64 {
	if m != nil {
		return m.FinishedAt
	}
	return 0
}

func (m *DownloadFileRecord) GetStatus() DownloadStatus {
	if m != nil {
		return m.Status
	}
	return DownloadStatus_DOWNLOAD_STATUS_UNSPECIFIED
}

// DownloadSegmentRecord 描述一个文件分片的详细信息及其下载状态
type DownloadSegmentRecord struct {
	// 文件片段的唯一标识，通常是该片段数据的哈希值
	// @gotags: badgerhold:"key"
	SegmentId string `protobuf:"bytes,1,opt,name=segment_id,json=segmentId,proto3" json:"segment_id,omitempty" badgerhold:"key"`
	// 文件片段的索引，表示该片段在文件中的顺序，从0开始
	// @gotags: badgerhold:"index"
	SegmentIndex int64 `protobuf:"varint,2,opt,name=segment_index,json=segmentIndex,proto3" json:"segment_index,omitempty" badgerhold:"index"`
	// 任务唯一标识
	// @gotags: badgerhold:"index"
	TaskId string `protobuf:"bytes,3,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty" badgerhold:"index"`
	// 分片大小，单位为字节，描述该片段的数据量大小
	Size_ int64 `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	// 当前片段的CRC32校验和
	// @gotags: badgerhold:"index"
	Crc32Checksum uint32 `protobuf:"varint,5,opt,name=crc32_checksum,json=crc32Checksum,proto3" json:"crc32_checksum,omitempty" badgerhold:"index"`
	// 当前片段的解密后内容
	SegmentContent []byte `protobuf:"bytes,6,opt,name=segment_content,json=segmentContent,proto3" json:"segment_content,omitempty"`
	// 是否是纠删码片段，用于标识该片段是原始数据还是冗余数据
	IsRsCodes bool `protobuf:"varint,7,opt,name=is_rs_codes,json=isRsCodes,proto3" json:"is_rs_codes,omitempty"`
	// 分片所在节点，及其是否可用
	SegmentNode map[string]bool `protobuf:"bytes,8,rep,name=segment_node,json=segmentNode,proto3" json:"segment_node,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// 分片的下载状态，描述该片段的下载进度和结果
	// @gotags: badgerhold:"index"
	Status               SegmentDownloadStatus `protobuf:"varint,9,opt,name=status,proto3,enum=pb.SegmentDownloadStatus" json:"status,omitempty" badgerhold:"index"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *DownloadSegmentRecord) Reset()         { *m = DownloadSegmentRecord{} }
func (m *DownloadSegmentRecord) String() string { return proto.CompactTextString(m) }
func (*DownloadSegmentRecord) ProtoMessage()    {}
func (*DownloadSegmentRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_01c5336762b2111d, []int{1}
}
func (m *DownloadSegmentRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadSegmentRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadSegmentRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadSegmentRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadSegmentRecord.Merge(m, src)
}
func (m *DownloadSegmentRecord) XXX_Size() int {
	return m.Size()
}
func (m *DownloadSegmentRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadSegmentRecord.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadSegmentRecord proto.InternalMessageInfo

func (m *DownloadSegmentRecord) GetSegmentId() string {
	if m != nil {
		return m.SegmentId
	}
	return ""
}

func (m *DownloadSegmentRecord) GetSegmentIndex() int64 {
	if m != nil {
		return m.SegmentIndex
	}
	return 0
}

func (m *DownloadSegmentRecord) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *DownloadSegmentRecord) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *DownloadSegmentRecord) GetCrc32Checksum() uint32 {
	if m != nil {
		return m.Crc32Checksum
	}
	return 0
}

func (m *DownloadSegmentRecord) GetSegmentContent() []byte {
	if m != nil {
		return m.SegmentContent
	}
	return nil
}

func (m *DownloadSegmentRecord) GetIsRsCodes() bool {
	if m != nil {
		return m.IsRsCodes
	}
	return false
}

func (m *DownloadSegmentRecord) GetSegmentNode() map[string]bool {
	if m != nil {
		return m.SegmentNode
	}
	return nil
}

func (m *DownloadSegmentRecord) GetStatus() SegmentDownloadStatus {
	if m != nil {
		return m.Status
	}
	return SegmentDownloadStatus_SEGMENT_DOWNLOAD_STATUS_UNSPECIFIED
}

// DownloadChan 用于刷新下载任务的通道
type DownloadChan struct {
	// 任务唯一标识，通常是该片段数据的哈希值
	TaskId string `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// 下载任务是否完成的标志
	IsComplete bool `protobuf:"varint,2,opt,name=is_complete,json=isComplete,proto3" json:"is_complete,omitempty"`
	// 下载进度百分比，范围0-100
	DownloadProgress int64 `protobuf:"varint,3,opt,name=download_progress,json=downloadProgress,proto3" json:"download_progress,omitempty"`
	// 文件总片段数量，数据片段+校验片段
	TotalShards int64 `protobuf:"varint,4,opt,name=total_shards,json=totalShards,proto3" json:"total_shards,omitempty"`
	// 文件片段唯一标识
	SegmentId string `protobuf:"bytes,5,opt,name=segment_id,json=segmentId,proto3" json:"segment_id,omitempty"`
	// 文件片段索引，表示该片段在文件中的顺序
	SegmentIndex int64 `protobuf:"varint,6,opt,name=segment_index,json=segmentIndex,proto3" json:"segment_index,omitempty"`
	// 文件片段大小，单位为字节
	SegmentSize int64 `protobuf:"varint,7,opt,name=segment_size,json=segmentSize,proto3" json:"segment_size,omitempty"`
	// 是否为纠删码冗余分片
	IsRsCodes bool `protobuf:"varint,8,opt,name=is_rs_codes,json=isRsCodes,proto3" json:"is_rs_codes,omitempty"`
	// 存储该文件片段的节点ID
	NodeId string `protobuf:"bytes,9,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// 下载完成时间的时间戳
	DownloadTime         int64    `protobuf:"varint,10,opt,name=download_time,json=downloadTime,proto3" json:"download_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadChan) Reset()         { *m = DownloadChan{} }
func (m *DownloadChan) String() string { return proto.CompactTextString(m) }
func (*DownloadChan) ProtoMessage()    {}
func (*DownloadChan) Descriptor() ([]byte, []int) {
	return fileDescriptor_01c5336762b2111d, []int{2}
}
func (m *DownloadChan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadChan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadChan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadChan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadChan.Merge(m, src)
}
func (m *DownloadChan) XXX_Size() int {
	return m.Size()
}
func (m *DownloadChan) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadChan.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadChan proto.InternalMessageInfo

func (m *DownloadChan) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *DownloadChan) GetIsComplete() bool {
	if m != nil {
		return m.IsComplete
	}
	return false
}

func (m *DownloadChan) GetDownloadProgress() int64 {
	if m != nil {
		return m.DownloadProgress
	}
	return 0
}

func (m *DownloadChan) GetTotalShards() int64 {
	if m != nil {
		return m.TotalShards
	}
	return 0
}

func (m *DownloadChan) GetSegmentId() string {
	if m != nil {
		return m.SegmentId
	}
	return ""
}

func (m *DownloadChan) GetSegmentIndex() int64 {
	if m != nil {
		return m.SegmentIndex
	}
	return 0
}

func (m *DownloadChan) GetSegmentSize() int64 {
	if m != nil {
		return m.SegmentSize
	}
	return 0
}

func (m *DownloadChan) GetIsRsCodes() bool {
	if m != nil {
		return m.IsRsCodes
	}
	return false
}

func (m *DownloadChan) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *DownloadChan) GetDownloadTime() int64 {
	if m != nil {
		return m.DownloadTime
	}
	return 0
}

// DownloadOperationInfo 表示下载操作的预处理或返回信息
type DownloadOperationInfo struct {
	// 任务唯一标识，用于区分和管理不同的下载任务
	TaskId string `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// 文件路径，指定要下载的文件在本地系统中的位置
	FilePath string `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	// 文件唯一标识，用于在系统内部唯一区分文件，通常是哈希值或UUID
	FileId string `protobuf:"bytes,3,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	// 文件的基本元数据信息，包括文件名、大小等
	FileMeta *FileMeta `protobuf:"bytes,4,opt,name=file_meta,json=fileMeta,proto3" json:"file_meta,omitempty"`
	// 数据片段数量，表示文件被分割成的片段数
	DataShards int64 `protobuf:"varint,5,opt,name=data_shards,json=dataShards,proto3" json:"data_shards,omitempty"`
	// 校验片段数量，用于纠删码的冗余片段数
	ParityShards int64 `protobuf:"varint,6,opt,name=parity_shards,json=parityShards,proto3" json:"parity_shards,omitempty"`
	// 文件片段大小，单位为字节
	SegmentSize int64 `protobuf:"varint,7,opt,name=segment_size,json=segmentSize,proto3" json:"segment_size,omitempty"`
	// 奇偶校验片段占比，表示冗余数据占总数据的比例
	ParityRatio float64 `protobuf:"fixed64,8,opt,name=parity_ratio,json=parityRatio,proto3" json:"parity_ratio,omitempty"`
	// 文件开始下载的时间戳，记录下载操作开始的精确时间
	UploadTime int64 `protobuf:"varint,9,opt,name=upload_time,json=uploadTime,proto3" json:"upload_time,omitempty"`
	// 下载操作的状态，反映当前下载任务的进展情况
	Status               DownloadStatus `protobuf:"varint,10,opt,name=status,proto3,enum=pb.DownloadStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *DownloadOperationInfo) Reset()         { *m = DownloadOperationInfo{} }
func (m *DownloadOperationInfo) String() string { return proto.CompactTextString(m) }
func (*DownloadOperationInfo) ProtoMessage()    {}
func (*DownloadOperationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_01c5336762b2111d, []int{3}
}
func (m *DownloadOperationInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadOperationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadOperationInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadOperationInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadOperationInfo.Merge(m, src)
}
func (m *DownloadOperationInfo) XXX_Size() int {
	return m.Size()
}
func (m *DownloadOperationInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadOperationInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadOperationInfo proto.InternalMessageInfo

func (m *DownloadOperationInfo) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *DownloadOperationInfo) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *DownloadOperationInfo) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *DownloadOperationInfo) GetFileMeta() *FileMeta {
	if m != nil {
		return m.FileMeta
	}
	return nil
}

func (m *DownloadOperationInfo) GetDataShards() int64 {
	if m != nil {
		return m.DataShards
	}
	return 0
}

func (m *DownloadOperationInfo) GetParityShards() int64 {
	if m != nil {
		return m.ParityShards
	}
	return 0
}

func (m *DownloadOperationInfo) GetSegmentSize() int64 {
	if m != nil {
		return m.SegmentSize
	}
	return 0
}

func (m *DownloadOperationInfo) GetParityRatio() float64 {
	if m != nil {
		return m.ParityRatio
	}
	return 0
}

func (m *DownloadOperationInfo) GetUploadTime() int64 {
	if m != nil {
		return m.UploadTime
	}
	return 0
}

func (m *DownloadOperationInfo) GetStatus() DownloadStatus {
	if m != nil {
		return m.Status
	}
	return DownloadStatus_DOWNLOAD_STATUS_UNSPECIFIED
}

// DownloadPubSubFileInfoRequest 下载订阅文件信息请求
type DownloadPubSubFileInfoRequest struct {
	// 任务唯一标识，用于在系统中唯一识别该下载任务
	TaskId string `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// 文件唯一标识，用于在系统内部唯一区分文件，通常是哈希值或UUID
	FileId string `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	// 所有者的公钥哈希，用于身份验证和访问控制
	PubkeyHash []byte `protobuf:"bytes,3,opt,name=pubkey_hash,json=pubkeyHash,proto3" json:"pubkey_hash,omitempty"`
	// 请求者的 AddrInfo，包含 ID 和地址信息
	AddrInfo             []byte   `protobuf:"bytes,4,opt,name=addr_info,json=addrInfo,proto3" json:"addr_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadPubSubFileInfoRequest) Reset()         { *m = DownloadPubSubFileInfoRequest{} }
func (m *DownloadPubSubFileInfoRequest) String() string { return proto.CompactTextString(m) }
func (*DownloadPubSubFileInfoRequest) ProtoMessage()    {}
func (*DownloadPubSubFileInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_01c5336762b2111d, []int{4}
}
func (m *DownloadPubSubFileInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadPubSubFileInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadPubSubFileInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadPubSubFileInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadPubSubFileInfoRequest.Merge(m, src)
}
func (m *DownloadPubSubFileInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *DownloadPubSubFileInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadPubSubFileInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadPubSubFileInfoRequest proto.InternalMessageInfo

func (m *DownloadPubSubFileInfoRequest) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *DownloadPubSubFileInfoRequest) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *DownloadPubSubFileInfoRequest) GetPubkeyHash() []byte {
	if m != nil {
		return m.PubkeyHash
	}
	return nil
}

func (m *DownloadPubSubFileInfoRequest) GetAddrInfo() []byte {
	if m != nil {
		return m.AddrInfo
	}
	return nil
}

// DownloadPubSubFileInfoResponse 下载订阅文件信息响应
type DownloadPubSubFileInfoResponse struct {
	// 任务唯一标识，用于在系统中唯一识别该下载任务
	TaskId string `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// 文件唯一标识，用于在系统内部唯一区分文件，通常是哈希值或UUID
	FileId string `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	// 文件元数据，包含文件的基本信息如名称、大小等
	FileMeta *FileMeta `protobuf:"bytes,3,opt,name=file_meta,json=fileMeta,proto3" json:"file_meta,omitempty"`
	// 文件片段的哈希表，记录每个片段的哈希值，支持纠错和数据完整性验证
	SliceTable           map[int64]*HashTable `protobuf:"bytes,4,rep,name=slice_table,json=sliceTable,proto3" json:"slice_table,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *DownloadPubSubFileInfoResponse) Reset()         { *m = DownloadPubSubFileInfoResponse{} }
func (m *DownloadPubSubFileInfoResponse) String() string { return proto.CompactTextString(m) }
func (*DownloadPubSubFileInfoResponse) ProtoMessage()    {}
func (*DownloadPubSubFileInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_01c5336762b2111d, []int{5}
}
func (m *DownloadPubSubFileInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadPubSubFileInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadPubSubFileInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadPubSubFileInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadPubSubFileInfoResponse.Merge(m, src)
}
func (m *DownloadPubSubFileInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *DownloadPubSubFileInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadPubSubFileInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadPubSubFileInfoResponse proto.InternalMessageInfo

func (m *DownloadPubSubFileInfoResponse) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *DownloadPubSubFileInfoResponse) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *DownloadPubSubFileInfoResponse) GetFileMeta() *FileMeta {
	if m != nil {
		return m.FileMeta
	}
	return nil
}

func (m *DownloadPubSubFileInfoResponse) GetSliceTable() map[int64]*HashTable {
	if m != nil {
		return m.SliceTable
	}
	return nil
}

// DownloadPubSubManifestRequest 下载订阅索引清单请求
type DownloadPubSubManifestRequest struct {
	// 任务唯一标识，用于在系统中唯一识别该下载任务
	TaskId string `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// 文件唯一标识，用于在系统内部唯一区分文件，通常是哈希值或UUID
	FileId string `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	// 所有者的公钥哈希，用于身份验证和访问控制
	PubkeyHash []byte `protobuf:"bytes,3,opt,name=pubkey_hash,json=pubkeyHash,proto3" json:"pubkey_hash,omitempty"`
	// 请求者的 AddrInfo，包含 ID 和地址信息
	AddrInfo []byte `protobuf:"bytes,4,opt,name=addr_info,json=addrInfo,proto3" json:"addr_info,omitempty"`
	// 请求下载的文件片段唯一标识数组
	RequestedSegmentIds  []string `protobuf:"bytes,5,rep,name=requested_segment_ids,json=requestedSegmentIds,proto3" json:"requested_segment_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadPubSubManifestRequest) Reset()         { *m = DownloadPubSubManifestRequest{} }
func (m *DownloadPubSubManifestRequest) String() string { return proto.CompactTextString(m) }
func (*DownloadPubSubManifestRequest) ProtoMessage()    {}
func (*DownloadPubSubManifestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_01c5336762b2111d, []int{6}
}
func (m *DownloadPubSubManifestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadPubSubManifestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadPubSubManifestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadPubSubManifestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadPubSubManifestRequest.Merge(m, src)
}
func (m *DownloadPubSubManifestRequest) XXX_Size() int {
	return m.Size()
}
func (m *DownloadPubSubManifestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadPubSubManifestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadPubSubManifestRequest proto.InternalMessageInfo

func (m *DownloadPubSubManifestRequest) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *DownloadPubSubManifestRequest) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *DownloadPubSubManifestRequest) GetPubkeyHash() []byte {
	if m != nil {
		return m.PubkeyHash
	}
	return nil
}

func (m *DownloadPubSubManifestRequest) GetAddrInfo() []byte {
	if m != nil {
		return m.AddrInfo
	}
	return nil
}

func (m *DownloadPubSubManifestRequest) GetRequestedSegmentIds() []string {
	if m != nil {
		return m.RequestedSegmentIds
	}
	return nil
}

// DownloadPubSubManifestResponse 下载订阅索引清单响应
type DownloadPubSubManifestResponse struct {
	// 任务唯一标识，用于在系统中唯一识别该下载任务
	TaskId string `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// 本地可用的分片索引数组
	AvailableSlices      map[int64]string `protobuf:"bytes,5,rep,name=available_slices,json=availableSlices,proto3" json:"available_slices,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *DownloadPubSubManifestResponse) Reset()         { *m = DownloadPubSubManifestResponse{} }
func (m *DownloadPubSubManifestResponse) String() string { return proto.CompactTextString(m) }
func (*DownloadPubSubManifestResponse) ProtoMessage()    {}
func (*DownloadPubSubManifestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_01c5336762b2111d, []int{7}
}
func (m *DownloadPubSubManifestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadPubSubManifestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadPubSubManifestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadPubSubManifestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadPubSubManifestResponse.Merge(m, src)
}
func (m *DownloadPubSubManifestResponse) XXX_Size() int {
	return m.Size()
}
func (m *DownloadPubSubManifestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadPubSubManifestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadPubSubManifestResponse proto.InternalMessageInfo

func (m *DownloadPubSubManifestResponse) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *DownloadPubSubManifestResponse) GetAvailableSlices() map[int64]string {
	if m != nil {
		return m.AvailableSlices
	}
	return nil
}

// SegmentContentRequest 文件片段内容请求
type SegmentContentRequest struct {
	// 任务唯一标识，用于在系统中唯一识别该下载任务
	TaskId string `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// 文件唯一标识，用于在系统内部唯一区分文件，通常是哈希值或UUID
	FileId string `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	// 所有者的公钥哈希，用于身份验证和访问控制
	PubkeyHash []byte `protobuf:"bytes,3,opt,name=pubkey_hash,json=pubkeyHash,proto3" json:"pubkey_hash,omitempty"`
	// 请求者的 AddrInfo，包含 ID 和地址信息
	AddrInfo []byte `protobuf:"bytes,4,opt,name=addr_info,json=addrInfo,proto3" json:"addr_info,omitempty"`
	// 文件片段的唯一标识，通常是该片段数据的哈希值
	SegmentId string `protobuf:"bytes,5,opt,name=segment_id,json=segmentId,proto3" json:"segment_id,omitempty"`
	// 文件片段索引，表示该片段在文件中的顺序
	SegmentIndex int64 `protobuf:"varint,6,opt,name=segment_index,json=segmentIndex,proto3" json:"segment_index,omitempty"`
	// 请求下载的文件片段唯一标识数组，用于批量请求
	RequestedSegmentIds  []string `protobuf:"bytes,7,rep,name=requested_segment_ids,json=requestedSegmentIds,proto3" json:"requested_segment_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SegmentContentRequest) Reset()         { *m = SegmentContentRequest{} }
func (m *SegmentContentRequest) String() string { return proto.CompactTextString(m) }
func (*SegmentContentRequest) ProtoMessage()    {}
func (*SegmentContentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_01c5336762b2111d, []int{8}
}
func (m *SegmentContentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SegmentContentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SegmentContentRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SegmentContentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SegmentContentRequest.Merge(m, src)
}
func (m *SegmentContentRequest) XXX_Size() int {
	return m.Size()
}
func (m *SegmentContentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SegmentContentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SegmentContentRequest proto.InternalMessageInfo

func (m *SegmentContentRequest) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *SegmentContentRequest) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *SegmentContentRequest) GetPubkeyHash() []byte {
	if m != nil {
		return m.PubkeyHash
	}
	return nil
}

func (m *SegmentContentRequest) GetAddrInfo() []byte {
	if m != nil {
		return m.AddrInfo
	}
	return nil
}

func (m *SegmentContentRequest) GetSegmentId() string {
	if m != nil {
		return m.SegmentId
	}
	return ""
}

func (m *SegmentContentRequest) GetSegmentIndex() int64 {
	if m != nil {
		return m.SegmentIndex
	}
	return 0
}

func (m *SegmentContentRequest) GetRequestedSegmentIds() []string {
	if m != nil {
		return m.RequestedSegmentIds
	}
	return nil
}

// SegmentContentResponse 文件片段内容响应
type SegmentContentResponse struct {
	// 任务唯一标识，用于在系统中唯一识别该下载任务
	TaskId string `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// 文件唯一标识，用于在系统内部唯一区分文件，通常是哈希值或UUID
	FileId string `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	// 文件元数据，包含文件的基本信息如名称、大小等
	FileMeta *FileMeta `protobuf:"bytes,3,opt,name=file_meta,json=fileMeta,proto3" json:"file_meta,omitempty"`
	// P2PK 脚本，用于进行文件验签操作
	P2PkScript []byte `protobuf:"bytes,4,opt,name=p2pk_script,json=p2pkScript,proto3" json:"p2pk_script,omitempty"`
	// 文件片段的唯一标识，通常是该片段数据的哈希值
	SegmentId string `protobuf:"bytes,5,opt,name=segment_id,json=segmentId,proto3" json:"segment_id,omitempty"`
	// 文件片段的索引，表示该片段在文件中的顺序
	SegmentIndex int64 `protobuf:"varint,6,opt,name=segment_index,json=segmentIndex,proto3" json:"segment_index,omitempty"`
	// 分片的CRC32校验和
	Crc32Checksum uint32 `protobuf:"varint,7,opt,name=crc32_checksum,json=crc32Checksum,proto3" json:"crc32_checksum,omitempty"`
	// 文件片段的内容(加密)，存储实际的加密后的数据
	SegmentContent []byte `protobuf:"bytes,8,opt,name=segment_content,json=segmentContent,proto3" json:"segment_content,omitempty"`
	// 文件加密密钥，用于解密文件内容
	EncryptionKey []byte `protobuf:"bytes,9,opt,name=encryption_key,json=encryptionKey,proto3" json:"encryption_key,omitempty"`
	// 文件和文件片段的数据签名，用于验证数据的真实性和完整性
	Signature []byte `protobuf:"bytes,10,opt,name=signature,proto3" json:"signature,omitempty"`
	// 文件片段的哈希表，记录每个片段的哈希值，支持纠错和数据完整性验证
	SliceTable map[int64]*HashTable `protobuf:"bytes,11,rep,name=slice_table,json=sliceTable,proto3" json:"slice_table,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// 本地可用的分片索引数组
	AvailableSlices      map[int64]string `protobuf:"bytes,12,rep,name=available_slices,json=availableSlices,proto3" json:"available_slices,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SegmentContentResponse) Reset()         { *m = SegmentContentResponse{} }
func (m *SegmentContentResponse) String() string { return proto.CompactTextString(m) }
func (*SegmentContentResponse) ProtoMessage()    {}
func (*SegmentContentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_01c5336762b2111d, []int{9}
}
func (m *SegmentContentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SegmentContentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SegmentContentResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SegmentContentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SegmentContentResponse.Merge(m, src)
}
func (m *SegmentContentResponse) XXX_Size() int {
	return m.Size()
}
func (m *SegmentContentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SegmentContentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SegmentContentResponse proto.InternalMessageInfo

func (m *SegmentContentResponse) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *SegmentContentResponse) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *SegmentContentResponse) GetFileMeta() *FileMeta {
	if m != nil {
		return m.FileMeta
	}
	return nil
}

func (m *SegmentContentResponse) GetP2PkScript() []byte {
	if m != nil {
		return m.P2PkScript
	}
	return nil
}

func (m *SegmentContentResponse) GetSegmentId() string {
	if m != nil {
		return m.SegmentId
	}
	return ""
}

func (m *SegmentContentResponse) GetSegmentIndex() int64 {
	if m != nil {
		return m.SegmentIndex
	}
	return 0
}

func (m *SegmentContentResponse) GetCrc32Checksum() uint32 {
	if m != nil {
		return m.Crc32Checksum
	}
	return 0
}

func (m *SegmentContentResponse) GetSegmentContent() []byte {
	if m != nil {
		return m.SegmentContent
	}
	return nil
}

func (m *SegmentContentResponse) GetEncryptionKey() []byte {
	if m != nil {
		return m.EncryptionKey
	}
	return nil
}

func (m *SegmentContentResponse) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *SegmentContentResponse) GetSliceTable() map[int64]*HashTable {
	if m != nil {
		return m.SliceTable
	}
	return nil
}

func (m *SegmentContentResponse) GetAvailableSlices() map[int64]string {
	if m != nil {
		return m.AvailableSlices
	}
	return nil
}

func init() {
	proto.RegisterEnum("pb.DownloadStatus", DownloadStatus_name, DownloadStatus_value)
	proto.RegisterEnum("pb.SegmentDownloadStatus", SegmentDownloadStatus_name, SegmentDownloadStatus_value)
	proto.RegisterType((*DownloadFileRecord)(nil), "pb.DownloadFileRecord")
	proto.RegisterMapType((map[int64]*HashTable)(nil), "pb.DownloadFileRecord.SliceTableEntry")
	proto.RegisterType((*DownloadSegmentRecord)(nil), "pb.DownloadSegmentRecord")
	proto.RegisterMapType((map[string]bool)(nil), "pb.DownloadSegmentRecord.SegmentNodeEntry")
	proto.RegisterType((*DownloadChan)(nil), "pb.DownloadChan")
	proto.RegisterType((*DownloadOperationInfo)(nil), "pb.DownloadOperationInfo")
	proto.RegisterType((*DownloadPubSubFileInfoRequest)(nil), "pb.DownloadPubSubFileInfoRequest")
	proto.RegisterType((*DownloadPubSubFileInfoResponse)(nil), "pb.DownloadPubSubFileInfoResponse")
	proto.RegisterMapType((map[int64]*HashTable)(nil), "pb.DownloadPubSubFileInfoResponse.SliceTableEntry")
	proto.RegisterType((*DownloadPubSubManifestRequest)(nil), "pb.DownloadPubSubManifestRequest")
	proto.RegisterType((*DownloadPubSubManifestResponse)(nil), "pb.DownloadPubSubManifestResponse")
	proto.RegisterMapType((map[int64]string)(nil), "pb.DownloadPubSubManifestResponse.AvailableSlicesEntry")
	proto.RegisterType((*SegmentContentRequest)(nil), "pb.SegmentContentRequest")
	proto.RegisterType((*SegmentContentResponse)(nil), "pb.SegmentContentResponse")
	proto.RegisterMapType((map[int64]string)(nil), "pb.SegmentContentResponse.AvailableSlicesEntry")
	proto.RegisterMapType((map[int64]*HashTable)(nil), "pb.SegmentContentResponse.SliceTableEntry")
}

func init() { proto.RegisterFile("pb/download.proto", fileDescriptor_01c5336762b2111d) }

var fileDescriptor_01c5336762b2111d = []byte{
	// 1278 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0x4f, 0x73, 0xdb, 0x44,
	0x14, 0x47, 0x56, 0x12, 0x5b, 0x4f, 0x76, 0xe2, 0x2e, 0xfd, 0xe3, 0x26, 0x24, 0x71, 0x9c, 0x69,
	0x6b, 0xc2, 0x4c, 0x3a, 0xb8, 0x07, 0x18, 0x0e, 0xcc, 0xb8, 0xb6, 0x92, 0x7a, 0x9a, 0x38, 0x19,
	0xc9, 0x1d, 0x66, 0xb8, 0x68, 0xd6, 0xd6, 0x3a, 0xd6, 0xc4, 0x96, 0x84, 0x76, 0x5d, 0x30, 0x9f,
	0x80, 0x1b, 0x5f, 0x81, 0x33, 0x1f, 0x81, 0x2b, 0x17, 0x8e, 0x5c, 0x39, 0x30, 0x53, 0x7a, 0xe4,
	0x4b, 0xc0, 0xec, 0x6a, 0x15, 0xd9, 0x8a, 0xed, 0x16, 0x26, 0xd0, 0x9b, 0xf5, 0x7b, 0x6f, 0x77,
	0xdf, 0xfb, 0xfd, 0xf6, 0xbd, 0xb7, 0x86, 0x5b, 0x41, 0xf7, 0xb1, 0xe3, 0x7f, 0xed, 0x0d, 0x7d,
	0xec, 0x1c, 0x06, 0xa1, 0xcf, 0x7c, 0x94, 0x09, 0xba, 0x9b, 0xc5, 0xa0, 0xfb, 0x98, 0x32, 0x3f,
	0xc4, 0x17, 0x24, 0x42, 0x2b, 0xaf, 0x54, 0x40, 0x4d, 0xe9, 0x78, 0xe4, 0x0e, 0x89, 0x49, 0x7a,
	0x7e, 0xe8, 0xa0, 0x7b, 0x90, 0x65, 0x98, 0x5e, 0xda, 0xae, 0x53, 0x52, 0xca, 0x4a, 0x55, 0x33,
	0xd7, 0xf8, 0x67, 0x4b, 0x18, 0xfa, 0xee, 0x90, 0x70, 0x43, 0x26, 0x32, 0xf0, 0xcf, 0x96, 0x83,
	0x76, 0x41, 0x0f, 0xc6, 0xdd, 0x4b, 0x32, 0xb1, 0x07, 0x98, 0x0e, 0x4a, 0x6a, 0x59, 0xa9, 0xe6,
	0x4d, 0x88, 0xa0, 0x67, 0x98, 0x0e, 0xd0, 0x43, 0xd8, 0xe8, 0xbb, 0x21, 0x65, 0x36, 0xf7, 0xa1,
	0x03, 0x1c, 0x92, 0xd2, 0x8a, 0x70, 0x2a, 0x08, 0xf8, 0x39, 0x99, 0x58, 0x1c, 0x44, 0x7b, 0x90,
	0x67, 0x64, 0x14, 0xd8, 0x32, 0xce, 0xd2, 0xaa, 0x38, 0x46, 0xe7, 0x98, 0x15, 0x41, 0xe8, 0x43,
	0xd0, 0x44, 0x10, 0x23, 0xc2, 0x70, 0x69, 0xad, 0xac, 0x54, 0xf5, 0x5a, 0xfe, 0x30, 0xe8, 0x1e,
	0xf2, 0x04, 0x4e, 0x09, 0xc3, 0x66, 0xae, 0x2f, 0x7f, 0xa1, 0x63, 0xd0, 0xe9, 0xd0, 0xed, 0x11,
	0x9b, 0xe1, 0xee, 0x90, 0x94, 0xb2, 0x65, 0xb5, 0xaa, 0xd7, 0x1e, 0x72, 0xe7, 0xeb, 0x59, 0x1f,
	0x5a, 0xdc, 0xb3, 0xc3, 0x1d, 0x0d, 0x8f, 0x85, 0x13, 0x13, 0xe8, 0x15, 0x80, 0xb6, 0x01, 0x28,
	0xc3, 0x21, 0x23, 0x8e, 0x8d, 0x59, 0x29, 0x57, 0x56, 0xaa, 0xaa, 0xa9, 0x49, 0xa4, 0xce, 0x78,
	0xfa, 0x7d, 0xd7, 0x73, 0xe9, 0x20, 0xb2, 0x6b, 0xc2, 0x0e, 0x31, 0x54, 0x67, 0xe8, 0x00, 0xd6,
	0x28, 0xc3, 0x6c, 0x4c, 0x4b, 0x50, 0x56, 0xaa, 0xeb, 0x35, 0x34, 0x1d, 0x83, 0x25, 0x2c, 0xa6,
	0xf4, 0xd8, 0x3c, 0x81, 0x8d, 0x54, 0x28, 0xa8, 0x08, 0xea, 0x25, 0x99, 0x08, 0x31, 0x54, 0x93,
	0xff, 0x44, 0xfb, 0xb0, 0xfa, 0x12, 0x0f, 0xc7, 0x44, 0xe8, 0xa0, 0xd7, 0x0a, 0x7c, 0x3f, 0x4e,
	0xb4, 0x58, 0x64, 0x46, 0xb6, 0xcf, 0x32, 0x9f, 0x2a, 0x95, 0x9f, 0x54, 0xb8, 0x73, 0x75, 0x10,
	0xb9, 0x18, 0x11, 0x8f, 0x49, 0x95, 0x79, 0x4e, 0x11, 0x90, 0x08, 0xad, 0x49, 0xa4, 0xe5, 0xa0,
	0x7d, 0x28, 0x5c, 0x99, 0x3d, 0x87, 0x7c, 0x23, 0x4e, 0x52, 0xcd, 0x7c, 0xec, 0xc1, 0xb1, 0xe9,
	0x9b, 0xa2, 0xce, 0xdc, 0x14, 0x04, 0x2b, 0xd4, 0xfd, 0x36, 0x12, 0x59, 0x35, 0xc5, 0x6f, 0xf4,
	0x00, 0xd6, 0x7b, 0x61, 0xef, 0x49, 0xcd, 0xee, 0x0d, 0x48, 0xef, 0x92, 0x8e, 0x47, 0x42, 0xdd,
	0x82, 0x59, 0x10, 0x68, 0x43, 0x82, 0xe8, 0x11, 0x6c, 0xc4, 0x07, 0xf7, 0x7c, 0x8f, 0x11, 0x8f,
	0x09, 0x95, 0xf3, 0xe6, 0xba, 0x84, 0x1b, 0x11, 0x8a, 0x76, 0x40, 0x77, 0xa9, 0x1d, 0x52, 0xbb,
	0xe7, 0x3b, 0x84, 0x96, 0xb2, 0x65, 0xa5, 0x9a, 0x33, 0x35, 0x97, 0x9a, 0xb4, 0xc1, 0x01, 0x74,
	0x0a, 0x71, 0xb0, 0xb6, 0xe7, 0x3b, 0xa4, 0x94, 0x13, 0xf2, 0x1f, 0xcc, 0x50, 0x3f, 0xcd, 0xc8,
	0xa1, 0xfc, 0x6a, 0xfb, 0x8e, 0xbc, 0x02, 0x3a, 0x4d, 0x10, 0xf4, 0xf1, 0x95, 0x86, 0x9a, 0xd0,
	0xf0, 0x3e, 0xdf, 0x48, 0x2e, 0x59, 0x20, 0xe5, 0xe7, 0x50, 0x4c, 0xef, 0x39, 0xad, 0xa5, 0x16,
	0x69, 0x79, 0x7b, 0x5a, 0xcb, 0xdc, 0xb4, 0x78, 0xbf, 0x67, 0x20, 0x1f, 0x6f, 0xdd, 0x18, 0x60,
	0x6f, 0x71, 0x65, 0xee, 0x0a, 0x2e, 0x7a, 0xfe, 0x28, 0x18, 0x12, 0x16, 0xef, 0x04, 0x2e, 0x6d,
	0x48, 0x04, 0x7d, 0x04, 0xb7, 0xe2, 0x96, 0x60, 0x07, 0xa1, 0x7f, 0x11, 0x12, 0x4a, 0x85, 0x66,
	0xaa, 0x59, 0x8c, 0x0d, 0xe7, 0x12, 0x17, 0x55, 0xe8, 0x33, 0x3c, 0x14, 0x95, 0xea, 0x50, 0xa9,
	0xa2, 0x2e, 0x30, 0x4b, 0x40, 0xa9, 0xdb, 0xb3, 0xfa, 0xc6, 0xdb, 0xb3, 0x36, 0xe7, 0xf6, 0xec,
	0x25, 0x02, 0x89, 0xcb, 0x92, 0x8d, 0x8e, 0x91, 0x98, 0xc5, 0xef, 0x4c, 0x4a, 0xe3, 0x5c, 0x5a,
	0xe3, 0x7b, 0x90, 0xe5, 0xda, 0xf2, 0x18, 0xb4, 0x88, 0x10, 0xfe, 0x19, 0x05, 0x70, 0x95, 0x2f,
	0x73, 0x47, 0x44, 0x14, 0x9e, 0x6a, 0xe6, 0x63, 0xb0, 0xe3, 0x8e, 0x48, 0xe5, 0xcf, 0x4c, 0x52,
	0x1c, 0x67, 0x01, 0x09, 0x31, 0x73, 0x7d, 0xaf, 0xe5, 0xf5, 0xfd, 0xc5, 0x44, 0x6f, 0xc9, 0xee,
	0x13, 0x60, 0x36, 0x90, 0x4d, 0x50, 0xf4, 0x9b, 0x73, 0xcc, 0x06, 0xd3, 0xfd, 0x51, 0x9d, 0xe9,
	0x8f, 0x33, 0x3d, 0x6b, 0x65, 0x69, 0xcf, 0xda, 0x05, 0xdd, 0xc1, 0x0c, 0xc7, 0xd4, 0xaf, 0x46,
	0xbd, 0x84, 0x43, 0x92, 0xf9, 0x7d, 0x28, 0x04, 0x38, 0x74, 0xd9, 0x24, 0x76, 0x91, 0xd4, 0x46,
	0xa0, 0x74, 0x7a, 0x0b, 0x6a, 0xf7, 0x40, 0x2e, 0xb1, 0x45, 0xde, 0x82, 0x5b, 0xc5, 0xd4, 0x23,
	0xcc, 0xe4, 0x10, 0x8f, 0x65, 0x1c, 0x24, 0x14, 0xca, 0xbe, 0x16, 0x41, 0x9c, 0xc0, 0x7f, 0xd2,
	0xd7, 0x2a, 0xdf, 0x2b, 0xb0, 0x1d, 0x9b, 0xce, 0xc7, 0x5d, 0x6b, 0xdc, 0xe5, 0xd9, 0x73, 0xb6,
	0x4d, 0xf2, 0xd5, 0x98, 0x50, 0xf6, 0x5f, 0xcc, 0x9d, 0x2d, 0xd0, 0xb0, 0xe3, 0x84, 0xb6, 0xeb,
	0xf5, 0x7d, 0x39, 0x71, 0x72, 0x1c, 0xe0, 0xc7, 0x56, 0x7e, 0xc8, 0xc0, 0xce, 0xa2, 0x88, 0x68,
	0xe0, 0x7b, 0x94, 0xfc, 0x8b, 0x90, 0x66, 0xa4, 0x56, 0x97, 0x4a, 0x6d, 0xcd, 0x8e, 0xa7, 0x15,
	0xd1, 0x9f, 0x6a, 0xd3, 0x14, 0xce, 0x8f, 0x6a, 0xd9, 0xa8, 0xba, 0xe1, 0xf1, 0xf1, 0xf3, 0x35,
	0xd1, 0x4e, 0xb1, 0xe7, 0xf6, 0x09, 0x65, 0xef, 0x48, 0x34, 0x54, 0x83, 0x3b, 0x61, 0x74, 0x34,
	0x71, 0xec, 0xa4, 0x05, 0xf1, 0x4a, 0x51, 0xab, 0x9a, 0xf9, 0xfe, 0x95, 0xd1, 0x8a, 0x9b, 0x11,
	0xad, 0xfc, 0xa1, 0xa4, 0x85, 0x4e, 0xb2, 0x78, 0x93, 0xd0, 0x5d, 0x28, 0xe2, 0x97, 0xd8, 0x1d,
	0x72, 0x66, 0x6c, 0xc1, 0x73, 0x74, 0x94, 0x5e, 0xfb, 0xe4, 0xba, 0x52, 0xe9, 0x6d, 0x0f, 0xeb,
	0xf1, 0x52, 0xa1, 0x09, 0x8d, 0xe4, 0xda, 0xc0, 0xb3, 0xe8, 0xe6, 0x53, 0xb8, 0x3d, 0xcf, 0x71,
	0x8e, 0x70, 0x33, 0xb3, 0x42, 0x9b, 0x56, 0xea, 0x2f, 0x05, 0xee, 0x58, 0x33, 0x03, 0xf2, 0x5d,
	0x29, 0x74, 0x13, 0xa3, 0x61, 0xa1, 0xca, 0xd9, 0xc5, 0x2a, 0xff, 0xb8, 0x0a, 0x77, 0xd3, 0x0c,
	0xfc, 0x1f, 0x65, 0xcc, 0xd9, 0xaa, 0x05, 0x97, 0x36, 0xed, 0x85, 0x6e, 0xc0, 0x24, 0x1d, 0xc0,
	0x21, 0x4b, 0x20, 0x37, 0x42, 0xc8, 0xf5, 0xc7, 0x53, 0xf6, 0x2d, 0x1f, 0x4f, 0xb9, 0xb9, 0x8f,
	0xa7, 0x07, 0xb0, 0x4e, 0xbc, 0x5e, 0x38, 0x09, 0xf8, 0xc8, 0xe3, 0xaf, 0x72, 0xd1, 0xdd, 0xf3,
	0x66, 0x21, 0x41, 0x9f, 0x93, 0x09, 0xfa, 0x00, 0x34, 0xea, 0x5e, 0x78, 0x98, 0x8d, 0xc3, 0x68,
	0x84, 0xe6, 0xcd, 0x04, 0x40, 0xcf, 0x67, 0x1b, 0x98, 0x9e, 0x3c, 0xb0, 0xe6, 0xeb, 0xb0, 0xf4,
	0x8d, 0xfd, 0xe5, 0x9c, 0x42, 0xcb, 0x8b, 0x1d, 0x1f, 0x2f, 0xd9, 0xf1, 0xed, 0x0a, 0xec, 0x46,
	0x9b, 0xe2, 0x4d, 0x94, 0xeb, 0xc1, 0x77, 0x19, 0x58, 0x9f, 0x1d, 0x94, 0x68, 0x17, 0xb6, 0x9a,
	0x67, 0x5f, 0xb4, 0x4f, 0xce, 0xea, 0x4d, 0xdb, 0xea, 0xd4, 0x3b, 0x2f, 0x2c, 0xfb, 0x45, 0xdb,
	0x3a, 0x37, 0x1a, 0xad, 0xa3, 0x96, 0xd1, 0x2c, 0xbe, 0x87, 0xf6, 0x60, 0x3b, 0xed, 0x70, 0x64,
	0x74, 0x1a, 0xcf, 0x5a, 0xed, 0x63, 0xbb, 0xd5, 0x3e, 0x3a, 0x2b, 0x2a, 0x68, 0x0b, 0xee, 0xa5,
	0x5d, 0xce, 0x8d, 0x76, 0xb3, 0xd5, 0x3e, 0x2e, 0x66, 0xe6, 0x1d, 0x10, 0x7f, 0x73, 0x07, 0x15,
	0x6d, 0xc2, 0xdd, 0x6b, 0xab, 0xeb, 0x2f, 0x2c, 0xa3, 0x59, 0x5c, 0x41, 0xdb, 0x70, 0x3f, 0x6d,
	0x6b, 0x9c, 0x9d, 0x9e, 0x9f, 0x18, 0x1d, 0xa3, 0x59, 0x5c, 0x9d, 0xb7, 0xf4, 0xa8, 0xde, 0x3a,
	0x31, 0x9a, 0xc5, 0xb5, 0xb9, 0x4b, 0xeb, 0xed, 0x86, 0x71, 0xc2, 0xcd, 0xd9, 0x83, 0xdf, 0x92,
	0xce, 0x95, 0x62, 0xe4, 0x11, 0xec, 0x5b, 0xc6, 0xf1, 0xa9, 0xd1, 0xee, 0xd8, 0xcb, 0x99, 0xd9,
	0x87, 0xdd, 0x45, 0x8e, 0x71, 0xfa, 0xca, 0xb2, 0xdd, 0xa6, 0x69, 0xc8, 0xa0, 0x07, 0xb0, 0xb7,
	0xc8, 0x31, 0x49, 0x59, 0x45, 0x15, 0xd8, 0x59, 0xe4, 0x26, 0x53, 0x5f, 0x79, 0x9a, 0xff, 0xe5,
	0xf5, 0x8e, 0xf2, 0xeb, 0xeb, 0x1d, 0xe5, 0xd5, 0xeb, 0x1d, 0xa5, 0xbb, 0x26, 0xfe, 0x76, 0x3f,
	0xf9, 0x3b, 0x00, 0x00, 0xff, 0xff, 0x64, 0x20, 0x96, 0xb9, 0xa1, 0x0f, 0x00, 0x00,
}

func (m *DownloadFileRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadFileRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadFileRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x50
	}
	if m.FinishedAt != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.FinishedAt))
		i--
		dAtA[i] = 0x48
	}
	if m.StartedAt != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.StartedAt))
		i--
		dAtA[i] = 0x40
	}
	if len(m.SliceTable) > 0 {
		for k := range m.SliceTable {
			v := m.SliceTable[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintDownload(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintDownload(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintDownload(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.FileMeta != nil {
		{
			size, err := m.FileMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDownload(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.TempStorage) > 0 {
		i -= len(m.TempStorage)
		copy(dAtA[i:], m.TempStorage)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.TempStorage)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FirstKeyShare) > 0 {
		i -= len(m.FirstKeyShare)
		copy(dAtA[i:], m.FirstKeyShare)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.FirstKeyShare)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PubkeyHash) > 0 {
		i -= len(m.PubkeyHash)
		copy(dAtA[i:], m.PubkeyHash)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.PubkeyHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadSegmentRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadSegmentRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadSegmentRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x48
	}
	if len(m.SegmentNode) > 0 {
		for k := range m.SegmentNode {
			v := m.SegmentNode[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDownload(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDownload(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.IsRsCodes {
		i--
		if m.IsRsCodes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.SegmentContent) > 0 {
		i -= len(m.SegmentContent)
		copy(dAtA[i:], m.SegmentContent)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.SegmentContent)))
		i--
		dAtA[i] = 0x32
	}
	if m.Crc32Checksum != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.Crc32Checksum))
		i--
		dAtA[i] = 0x28
	}
	if m.Size_ != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SegmentIndex != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.SegmentIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SegmentId) > 0 {
		i -= len(m.SegmentId)
		copy(dAtA[i:], m.SegmentId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.SegmentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadChan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadChan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadChan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DownloadTime != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.DownloadTime))
		i--
		dAtA[i] = 0x50
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0x4a
	}
	if m.IsRsCodes {
		i--
		if m.IsRsCodes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.SegmentSize != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.SegmentSize))
		i--
		dAtA[i] = 0x38
	}
	if m.SegmentIndex != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.SegmentIndex))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SegmentId) > 0 {
		i -= len(m.SegmentId)
		copy(dAtA[i:], m.SegmentId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.SegmentId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.TotalShards != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.TotalShards))
		i--
		dAtA[i] = 0x20
	}
	if m.DownloadProgress != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.DownloadProgress))
		i--
		dAtA[i] = 0x18
	}
	if m.IsComplete {
		i--
		if m.IsComplete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadOperationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadOperationInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadOperationInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x50
	}
	if m.UploadTime != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.UploadTime))
		i--
		dAtA[i] = 0x48
	}
	if m.ParityRatio != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ParityRatio))))
		i--
		dAtA[i] = 0x41
	}
	if m.SegmentSize != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.SegmentSize))
		i--
		dAtA[i] = 0x38
	}
	if m.ParityShards != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.ParityShards))
		i--
		dAtA[i] = 0x30
	}
	if m.DataShards != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.DataShards))
		i--
		dAtA[i] = 0x28
	}
	if m.FileMeta != nil {
		{
			size, err := m.FileMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDownload(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FilePath) > 0 {
		i -= len(m.FilePath)
		copy(dAtA[i:], m.FilePath)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.FilePath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadPubSubFileInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadPubSubFileInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadPubSubFileInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AddrInfo) > 0 {
		i -= len(m.AddrInfo)
		copy(dAtA[i:], m.AddrInfo)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.AddrInfo)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PubkeyHash) > 0 {
		i -= len(m.PubkeyHash)
		copy(dAtA[i:], m.PubkeyHash)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.PubkeyHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadPubSubFileInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadPubSubFileInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadPubSubFileInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SliceTable) > 0 {
		for k := range m.SliceTable {
			v := m.SliceTable[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintDownload(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintDownload(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintDownload(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.FileMeta != nil {
		{
			size, err := m.FileMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDownload(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadPubSubManifestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadPubSubManifestRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadPubSubManifestRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RequestedSegmentIds) > 0 {
		for iNdEx := len(m.RequestedSegmentIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestedSegmentIds[iNdEx])
			copy(dAtA[i:], m.RequestedSegmentIds[iNdEx])
			i = encodeVarintDownload(dAtA, i, uint64(len(m.RequestedSegmentIds[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.AddrInfo) > 0 {
		i -= len(m.AddrInfo)
		copy(dAtA[i:], m.AddrInfo)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.AddrInfo)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PubkeyHash) > 0 {
		i -= len(m.PubkeyHash)
		copy(dAtA[i:], m.PubkeyHash)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.PubkeyHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadPubSubManifestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadPubSubManifestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadPubSubManifestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AvailableSlices) > 0 {
		for k := range m.AvailableSlices {
			v := m.AvailableSlices[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintDownload(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintDownload(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintDownload(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SegmentContentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SegmentContentRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SegmentContentRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RequestedSegmentIds) > 0 {
		for iNdEx := len(m.RequestedSegmentIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestedSegmentIds[iNdEx])
			copy(dAtA[i:], m.RequestedSegmentIds[iNdEx])
			i = encodeVarintDownload(dAtA, i, uint64(len(m.RequestedSegmentIds[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.SegmentIndex != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.SegmentIndex))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SegmentId) > 0 {
		i -= len(m.SegmentId)
		copy(dAtA[i:], m.SegmentId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.SegmentId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AddrInfo) > 0 {
		i -= len(m.AddrInfo)
		copy(dAtA[i:], m.AddrInfo)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.AddrInfo)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PubkeyHash) > 0 {
		i -= len(m.PubkeyHash)
		copy(dAtA[i:], m.PubkeyHash)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.PubkeyHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SegmentContentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SegmentContentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SegmentContentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AvailableSlices) > 0 {
		for k := range m.AvailableSlices {
			v := m.AvailableSlices[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintDownload(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintDownload(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintDownload(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.SliceTable) > 0 {
		for k := range m.SliceTable {
			v := m.SliceTable[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintDownload(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintDownload(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintDownload(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.EncryptionKey) > 0 {
		i -= len(m.EncryptionKey)
		copy(dAtA[i:], m.EncryptionKey)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.EncryptionKey)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SegmentContent) > 0 {
		i -= len(m.SegmentContent)
		copy(dAtA[i:], m.SegmentContent)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.SegmentContent)))
		i--
		dAtA[i] = 0x42
	}
	if m.Crc32Checksum != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.Crc32Checksum))
		i--
		dAtA[i] = 0x38
	}
	if m.SegmentIndex != 0 {
		i = encodeVarintDownload(dAtA, i, uint64(m.SegmentIndex))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SegmentId) > 0 {
		i -= len(m.SegmentId)
		copy(dAtA[i:], m.SegmentId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.SegmentId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.P2PkScript) > 0 {
		i -= len(m.P2PkScript)
		copy(dAtA[i:], m.P2PkScript)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.P2PkScript)))
		i--
		dAtA[i] = 0x22
	}
	if m.FileMeta != nil {
		{
			size, err := m.FileMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDownload(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintDownload(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDownload(dAtA []byte, offset int, v uint64) int {
	offset -= sovDownload(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DownloadFileRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.PubkeyHash)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.FirstKeyShare)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.TempStorage)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	if m.FileMeta != nil {
		l = m.FileMeta.Size()
		n += 1 + l + sovDownload(uint64(l))
	}
	if len(m.SliceTable) > 0 {
		for k, v := range m.SliceTable {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovDownload(uint64(l))
			}
			mapEntrySize := 1 + sovDownload(uint64(k)) + l
			n += mapEntrySize + 1 + sovDownload(uint64(mapEntrySize))
		}
	}
	if m.StartedAt != 0 {
		n += 1 + sovDownload(uint64(m.StartedAt))
	}
	if m.FinishedAt != 0 {
		n += 1 + sovDownload(uint64(m.FinishedAt))
	}
	if m.Status != 0 {
		n += 1 + sovDownload(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadSegmentRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SegmentId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	if m.SegmentIndex != 0 {
		n += 1 + sovDownload(uint64(m.SegmentIndex))
	}
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovDownload(uint64(m.Size_))
	}
	if m.Crc32Checksum != 0 {
		n += 1 + sovDownload(uint64(m.Crc32Checksum))
	}
	l = len(m.SegmentContent)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	if m.IsRsCodes {
		n += 2
	}
	if len(m.SegmentNode) > 0 {
		for k, v := range m.SegmentNode {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDownload(uint64(len(k))) + 1 + 1
			n += mapEntrySize + 1 + sovDownload(uint64(mapEntrySize))
		}
	}
	if m.Status != 0 {
		n += 1 + sovDownload(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadChan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	if m.IsComplete {
		n += 2
	}
	if m.DownloadProgress != 0 {
		n += 1 + sovDownload(uint64(m.DownloadProgress))
	}
	if m.TotalShards != 0 {
		n += 1 + sovDownload(uint64(m.TotalShards))
	}
	l = len(m.SegmentId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	if m.SegmentIndex != 0 {
		n += 1 + sovDownload(uint64(m.SegmentIndex))
	}
	if m.SegmentSize != 0 {
		n += 1 + sovDownload(uint64(m.SegmentSize))
	}
	if m.IsRsCodes {
		n += 2
	}
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	if m.DownloadTime != 0 {
		n += 1 + sovDownload(uint64(m.DownloadTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadOperationInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	if m.FileMeta != nil {
		l = m.FileMeta.Size()
		n += 1 + l + sovDownload(uint64(l))
	}
	if m.DataShards != 0 {
		n += 1 + sovDownload(uint64(m.DataShards))
	}
	if m.ParityShards != 0 {
		n += 1 + sovDownload(uint64(m.ParityShards))
	}
	if m.SegmentSize != 0 {
		n += 1 + sovDownload(uint64(m.SegmentSize))
	}
	if m.ParityRatio != 0 {
		n += 9
	}
	if m.UploadTime != 0 {
		n += 1 + sovDownload(uint64(m.UploadTime))
	}
	if m.Status != 0 {
		n += 1 + sovDownload(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadPubSubFileInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.PubkeyHash)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.AddrInfo)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadPubSubFileInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	if m.FileMeta != nil {
		l = m.FileMeta.Size()
		n += 1 + l + sovDownload(uint64(l))
	}
	if len(m.SliceTable) > 0 {
		for k, v := range m.SliceTable {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovDownload(uint64(l))
			}
			mapEntrySize := 1 + sovDownload(uint64(k)) + l
			n += mapEntrySize + 1 + sovDownload(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadPubSubManifestRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.PubkeyHash)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.AddrInfo)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	if len(m.RequestedSegmentIds) > 0 {
		for _, s := range m.RequestedSegmentIds {
			l = len(s)
			n += 1 + l + sovDownload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadPubSubManifestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	if len(m.AvailableSlices) > 0 {
		for k, v := range m.AvailableSlices {
			_ = k
			_ = v
			mapEntrySize := 1 + sovDownload(uint64(k)) + 1 + len(v) + sovDownload(uint64(len(v)))
			n += mapEntrySize + 1 + sovDownload(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SegmentContentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.PubkeyHash)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.AddrInfo)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.SegmentId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	if m.SegmentIndex != 0 {
		n += 1 + sovDownload(uint64(m.SegmentIndex))
	}
	if len(m.RequestedSegmentIds) > 0 {
		for _, s := range m.RequestedSegmentIds {
			l = len(s)
			n += 1 + l + sovDownload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SegmentContentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	if m.FileMeta != nil {
		l = m.FileMeta.Size()
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.P2PkScript)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.SegmentId)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	if m.SegmentIndex != 0 {
		n += 1 + sovDownload(uint64(m.SegmentIndex))
	}
	if m.Crc32Checksum != 0 {
		n += 1 + sovDownload(uint64(m.Crc32Checksum))
	}
	l = len(m.SegmentContent)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.EncryptionKey)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovDownload(uint64(l))
	}
	if len(m.SliceTable) > 0 {
		for k, v := range m.SliceTable {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovDownload(uint64(l))
			}
			mapEntrySize := 1 + sovDownload(uint64(k)) + l
			n += mapEntrySize + 1 + sovDownload(uint64(mapEntrySize))
		}
	}
	if len(m.AvailableSlices) > 0 {
		for k, v := range m.AvailableSlices {
			_ = k
			_ = v
			mapEntrySize := 1 + sovDownload(uint64(k)) + 1 + len(v) + sovDownload(uint64(len(v)))
			n += mapEntrySize + 1 + sovDownload(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDownload(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDownload(x uint64) (n int) {
	return sovDownload(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DownloadFileRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDownload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadFileRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadFileRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubkeyHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubkeyHash = append(m.PubkeyHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PubkeyHash == nil {
				m.PubkeyHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstKeyShare", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstKeyShare = append(m.FirstKeyShare[:0], dAtA[iNdEx:postIndex]...)
			if m.FirstKeyShare == nil {
				m.FirstKeyShare = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempStorage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TempStorage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileMeta == nil {
				m.FileMeta = &FileMeta{}
			}
			if err := m.FileMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SliceTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SliceTable == nil {
				m.SliceTable = make(map[int64]*HashTable)
			}
			var mapkey int64
			var mapvalue *HashTable
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDownload
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDownload
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDownload
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthDownload
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthDownload
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &HashTable{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDownload(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDownload
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SliceTable[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			m.StartedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishedAt", wireType)
			}
			m.FinishedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinishedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= DownloadStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDownload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDownload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadSegmentRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDownload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadSegmentRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadSegmentRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SegmentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentIndex", wireType)
			}
			m.SegmentIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentIndex |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc32Checksum", wireType)
			}
			m.Crc32Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crc32Checksum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentContent", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SegmentContent = append(m.SegmentContent[:0], dAtA[iNdEx:postIndex]...)
			if m.SegmentContent == nil {
				m.SegmentContent = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRsCodes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRsCodes = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SegmentNode == nil {
				m.SegmentNode = make(map[string]bool)
			}
			var mapkey string
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDownload
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDownload
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDownload
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDownload
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDownload
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDownload(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDownload
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SegmentNode[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SegmentDownloadStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDownload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDownload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadChan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDownload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadChan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadChan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsComplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsComplete = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadProgress", wireType)
			}
			m.DownloadProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownloadProgress |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalShards", wireType)
			}
			m.TotalShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalShards |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SegmentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentIndex", wireType)
			}
			m.SegmentIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentIndex |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentSize", wireType)
			}
			m.SegmentSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRsCodes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRsCodes = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadTime", wireType)
			}
			m.DownloadTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownloadTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDownload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDownload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadOperationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDownload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadOperationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadOperationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileMeta == nil {
				m.FileMeta = &FileMeta{}
			}
			if err := m.FileMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataShards", wireType)
			}
			m.DataShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataShards |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParityShards", wireType)
			}
			m.ParityShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParityShards |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentSize", wireType)
			}
			m.SegmentSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParityRatio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ParityRatio = float64(math.Float64frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTime", wireType)
			}
			m.UploadTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= DownloadStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDownload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDownload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadPubSubFileInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDownload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadPubSubFileInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadPubSubFileInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubkeyHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubkeyHash = append(m.PubkeyHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PubkeyHash == nil {
				m.PubkeyHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrInfo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddrInfo = append(m.AddrInfo[:0], dAtA[iNdEx:postIndex]...)
			if m.AddrInfo == nil {
				m.AddrInfo = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDownload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDownload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadPubSubFileInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDownload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadPubSubFileInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadPubSubFileInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileMeta == nil {
				m.FileMeta = &FileMeta{}
			}
			if err := m.FileMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SliceTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SliceTable == nil {
				m.SliceTable = make(map[int64]*HashTable)
			}
			var mapkey int64
			var mapvalue *HashTable
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDownload
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDownload
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDownload
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthDownload
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthDownload
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &HashTable{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDownload(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDownload
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SliceTable[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDownload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDownload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadPubSubManifestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDownload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadPubSubManifestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadPubSubManifestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubkeyHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubkeyHash = append(m.PubkeyHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PubkeyHash == nil {
				m.PubkeyHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrInfo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddrInfo = append(m.AddrInfo[:0], dAtA[iNdEx:postIndex]...)
			if m.AddrInfo == nil {
				m.AddrInfo = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedSegmentIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestedSegmentIds = append(m.RequestedSegmentIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDownload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDownload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadPubSubManifestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDownload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadPubSubManifestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadPubSubManifestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableSlices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AvailableSlices == nil {
				m.AvailableSlices = make(map[int64]string)
			}
			var mapkey int64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDownload
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDownload
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDownload
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDownload
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthDownload
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDownload(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDownload
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AvailableSlices[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDownload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDownload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SegmentContentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDownload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SegmentContentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SegmentContentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubkeyHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubkeyHash = append(m.PubkeyHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PubkeyHash == nil {
				m.PubkeyHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrInfo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddrInfo = append(m.AddrInfo[:0], dAtA[iNdEx:postIndex]...)
			if m.AddrInfo == nil {
				m.AddrInfo = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SegmentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentIndex", wireType)
			}
			m.SegmentIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentIndex |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedSegmentIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestedSegmentIds = append(m.RequestedSegmentIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDownload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDownload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SegmentContentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDownload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SegmentContentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SegmentContentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileMeta == nil {
				m.FileMeta = &FileMeta{}
			}
			if err := m.FileMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P2PkScript", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.P2PkScript = append(m.P2PkScript[:0], dAtA[iNdEx:postIndex]...)
			if m.P2PkScript == nil {
				m.P2PkScript = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SegmentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentIndex", wireType)
			}
			m.SegmentIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentIndex |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc32Checksum", wireType)
			}
			m.Crc32Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crc32Checksum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentContent", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SegmentContent = append(m.SegmentContent[:0], dAtA[iNdEx:postIndex]...)
			if m.SegmentContent == nil {
				m.SegmentContent = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionKey = append(m.EncryptionKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptionKey == nil {
				m.EncryptionKey = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SliceTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SliceTable == nil {
				m.SliceTable = make(map[int64]*HashTable)
			}
			var mapkey int64
			var mapvalue *HashTable
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDownload
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDownload
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDownload
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthDownload
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthDownload
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &HashTable{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDownload(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDownload
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SliceTable[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableSlices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDownload
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDownload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AvailableSlices == nil {
				m.AvailableSlices = make(map[int64]string)
			}
			var mapkey int64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDownload
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDownload
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDownload
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDownload
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthDownload
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDownload(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDownload
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AvailableSlices[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDownload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDownload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDownload(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDownload
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDownload
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDownload
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDownload
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDownload
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDownload        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDownload          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDownload = fmt.Errorf("proto: unexpected end of group")
)
