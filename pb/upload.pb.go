// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb/upload.proto

package pb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// UploadStatus 表示上传任务的状态
type UploadStatus int32

const (
	// 未指定状态，表示任务状态未初始化或未知
	UploadStatus_UPLOAD_STATUS_UNSPECIFIED UploadStatus = 0
	// 文件编码中，表示文件正在进行编码处理（如压缩、加密等）
	UploadStatus_UPLOAD_STATUS_ENCODING UploadStatus = 1
	// 待上传，任务已创建但尚未开始执行，等待系统调度
	UploadStatus_UPLOAD_STATUS_PENDING UploadStatus = 2
	// 上传中，任务正在执行文件上传操作，数据传输进行中
	UploadStatus_UPLOAD_STATUS_UPLOADING UploadStatus = 3
	// 已暂停，任务已被用户或系统暂停，可通过恢复操作继续执行
	UploadStatus_UPLOAD_STATUS_PAUSED UploadStatus = 4
	// 已完成，任务已成功完成所有上传操作，文件已全部传输到目标位置
	UploadStatus_UPLOAD_STATUS_COMPLETED UploadStatus = 5
	// 失败，任务由于以下原因未能成功完成：
	// - 网络连接超时或不稳定
	// - 编码过程发生错误（如加密失败、压缩失败）
	// - 存储设备空间不足
	// - 存储设备写入错误
	// - 文件系统权限问题
	UploadStatus_UPLOAD_STATUS_FAILED UploadStatus = 6
	// 已取消，任务被用户主动取消或系统因策略原因终止
	UploadStatus_UPLOAD_STATUS_CANCELED UploadStatus = 7
	// 文件异常，表示上传过程中检测到文件存在问题，如文件损坏、格式错误等
	UploadStatus_UPLOAD_STATUS_FILE_EXCEPTION UploadStatus = 8
)

var UploadStatus_name = map[int32]string{
	0: "UPLOAD_STATUS_UNSPECIFIED",
	1: "UPLOAD_STATUS_ENCODING",
	2: "UPLOAD_STATUS_PENDING",
	3: "UPLOAD_STATUS_UPLOADING",
	4: "UPLOAD_STATUS_PAUSED",
	5: "UPLOAD_STATUS_COMPLETED",
	6: "UPLOAD_STATUS_FAILED",
	7: "UPLOAD_STATUS_CANCELED",
	8: "UPLOAD_STATUS_FILE_EXCEPTION",
}

var UploadStatus_value = map[string]int32{
	"UPLOAD_STATUS_UNSPECIFIED":    0,
	"UPLOAD_STATUS_ENCODING":       1,
	"UPLOAD_STATUS_PENDING":        2,
	"UPLOAD_STATUS_UPLOADING":      3,
	"UPLOAD_STATUS_PAUSED":         4,
	"UPLOAD_STATUS_COMPLETED":      5,
	"UPLOAD_STATUS_FAILED":         6,
	"UPLOAD_STATUS_CANCELED":       7,
	"UPLOAD_STATUS_FILE_EXCEPTION": 8,
}

func (x UploadStatus) String() string {
	return proto.EnumName(UploadStatus_name, int32(x))
}

func (UploadStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6d5c292f53f1732c, []int{0}
}

// SegmentUploadStatus 表示文件片段的上传状态
type SegmentUploadStatus int32

const (
	// 未指定状态，表示片段状态未初始化或未知
	SegmentUploadStatus_SEGMENT_UPLOAD_STATUS_UNSPECIFIED SegmentUploadStatus = 0
	// 尚未准备好，文件片段尚未完成预处理或加密等准备工作
	SegmentUploadStatus_SEGMENT_UPLOAD_STATUS_NOT_READY SegmentUploadStatus = 1
	// 待上传，文件片段已准备好待上传但尚未开始传输
	SegmentUploadStatus_SEGMENT_UPLOAD_STATUS_PENDING SegmentUploadStatus = 2
	// 上传中，文件片段正在上传过程中，数据正在传输
	SegmentUploadStatus_SEGMENT_UPLOAD_STATUS_UPLOADING SegmentUploadStatus = 3
	// 已完成，文件片段已成功上传并通过完整性校验
	SegmentUploadStatus_SEGMENT_UPLOAD_STATUS_COMPLETED SegmentUploadStatus = 4
	// 失败，文件片段上传失败，可能是由于网络问题或服务器错误
	SegmentUploadStatus_SEGMENT_UPLOAD_STATUS_FAILED SegmentUploadStatus = 5
)

var SegmentUploadStatus_name = map[int32]string{
	0: "SEGMENT_UPLOAD_STATUS_UNSPECIFIED",
	1: "SEGMENT_UPLOAD_STATUS_NOT_READY",
	2: "SEGMENT_UPLOAD_STATUS_PENDING",
	3: "SEGMENT_UPLOAD_STATUS_UPLOADING",
	4: "SEGMENT_UPLOAD_STATUS_COMPLETED",
	5: "SEGMENT_UPLOAD_STATUS_FAILED",
}

var SegmentUploadStatus_value = map[string]int32{
	"SEGMENT_UPLOAD_STATUS_UNSPECIFIED": 0,
	"SEGMENT_UPLOAD_STATUS_NOT_READY":   1,
	"SEGMENT_UPLOAD_STATUS_PENDING":     2,
	"SEGMENT_UPLOAD_STATUS_UPLOADING":   3,
	"SEGMENT_UPLOAD_STATUS_COMPLETED":   4,
	"SEGMENT_UPLOAD_STATUS_FAILED":      5,
}

func (x SegmentUploadStatus) String() string {
	return proto.EnumName(SegmentUploadStatus_name, int32(x))
}

func (SegmentUploadStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6d5c292f53f1732c, []int{1}
}

// FileSecurity 封装了文件的安全和权限相关的信息
type FileSecurity struct {
	// 文件加密密钥，用于加密整个文件
	Secret []byte `protobuf:"bytes,1,opt,name=secret,proto3" json:"secret,omitempty"`
	// 文件加密密钥列表，用于在上传过程中保证文件数据的安全，支持多重加密
	EncryptionKey [][]byte `protobuf:"bytes,2,rep,name=encryption_key,json=encryptionKey,proto3" json:"encryption_key,omitempty"`
	// 所有者的私钥，用于文件片段签名（注意：在实际使用中，私钥不应该通过网络传输）
	OwnerPriv []byte `protobuf:"bytes,3,opt,name=owner_priv,json=ownerPriv,proto3" json:"owner_priv,omitempty"`
	// P2PKH 脚本，用于验证文件所有者的身份
	P2PkhScript []byte `protobuf:"bytes,4,opt,name=p2pkh_script,json=p2pkhScript,proto3" json:"p2pkh_script,omitempty"`
	// P2PK 脚本，用于进行文件验签操作
	P2PkScript           []byte   `protobuf:"bytes,5,opt,name=p2pk_script,json=p2pkScript,proto3" json:"p2pk_script,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileSecurity) Reset()         { *m = FileSecurity{} }
func (m *FileSecurity) String() string { return proto.CompactTextString(m) }
func (*FileSecurity) ProtoMessage()    {}
func (*FileSecurity) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d5c292f53f1732c, []int{0}
}
func (m *FileSecurity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileSecurity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileSecurity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileSecurity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileSecurity.Merge(m, src)
}
func (m *FileSecurity) XXX_Size() int {
	return m.Size()
}
func (m *FileSecurity) XXX_DiscardUnknown() {
	xxx_messageInfo_FileSecurity.DiscardUnknown(m)
}

var xxx_messageInfo_FileSecurity proto.InternalMessageInfo

func (m *FileSecurity) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

func (m *FileSecurity) GetEncryptionKey() [][]byte {
	if m != nil {
		return m.EncryptionKey
	}
	return nil
}

func (m *FileSecurity) GetOwnerPriv() []byte {
	if m != nil {
		return m.OwnerPriv
	}
	return nil
}

func (m *FileSecurity) GetP2PkhScript() []byte {
	if m != nil {
		return m.P2PkhScript
	}
	return nil
}

func (m *FileSecurity) GetP2PkScript() []byte {
	if m != nil {
		return m.P2PkScript
	}
	return nil
}

// UploadFileRecord 上传文件记录
type UploadFileRecord struct {
	// 任务唯一标识
	// @gotags: badgerhold:"key"
	TaskId string `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty" badgerhold:"key"`
	// 文件唯一标识,由文件内容和所有者私钥生成的SHA256哈希值
	// @gotags: badgerhold:"index"
	FileId string `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty" badgerhold:"index"`
	// 文件路径
	Path string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	// 文件的基本元数据
	FileMeta *FileMeta `protobuf:"bytes,4,opt,name=file_meta,json=fileMeta,proto3" json:"file_meta,omitempty"`
	// 文件的安全和权限相关信息
	FileSecurity *FileSecurity `protobuf:"bytes,5,opt,name=file_security,json=fileSecurity,proto3" json:"file_security,omitempty"`
	// 文件分片哈希表
	SliceTable map[int64]*HashTable `protobuf:"bytes,6,rep,name=slice_table,json=sliceTable,proto3" json:"slice_table,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// 文件上传的开始时间戳
	StartedAt int64 `protobuf:"varint,7,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	// 文件上传的完成时间戳
	FinishedAt int64 `protobuf:"varint,8,opt,name=finished_at,json=finishedAt,proto3" json:"finished_at,omitempty"`
	// 上传任务的当前状态
	// @gotags: badgerhold:"index"
	Status               UploadStatus `protobuf:"varint,9,opt,name=status,proto3,enum=pb.UploadStatus" json:"status,omitempty" badgerhold:"index"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *UploadFileRecord) Reset()         { *m = UploadFileRecord{} }
func (m *UploadFileRecord) String() string { return proto.CompactTextString(m) }
func (*UploadFileRecord) ProtoMessage()    {}
func (*UploadFileRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d5c292f53f1732c, []int{1}
}
func (m *UploadFileRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadFileRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadFileRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadFileRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadFileRecord.Merge(m, src)
}
func (m *UploadFileRecord) XXX_Size() int {
	return m.Size()
}
func (m *UploadFileRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadFileRecord.DiscardUnknown(m)
}

var xxx_messageInfo_UploadFileRecord proto.InternalMessageInfo

func (m *UploadFileRecord) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *UploadFileRecord) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *UploadFileRecord) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *UploadFileRecord) GetFileMeta() *FileMeta {
	if m != nil {
		return m.FileMeta
	}
	return nil
}

func (m *UploadFileRecord) GetFileSecurity() *FileSecurity {
	if m != nil {
		return m.FileSecurity
	}
	return nil
}

func (m *UploadFileRecord) GetSliceTable() map[int64]*HashTable {
	if m != nil {
		return m.SliceTable
	}
	return nil
}

func (m *UploadFileRecord) GetStartedAt() int64 {
	if m != nil {
		return m.StartedAt
	}
	return 0
}

func (m *UploadFileRecord) GetFinishedAt() int64 {
	if m != nil {
		return m.FinishedAt
	}
	return 0
}

func (m *UploadFileRecord) GetStatus() UploadStatus {
	if m != nil {
		return m.Status
	}
	return UploadStatus_UPLOAD_STATUS_UNSPECIFIED
}

// UploadSegmentRecord 上传文件片段记录
type UploadSegmentRecord struct {
	// 当前片段的唯一标识,由file_id和segment_index生成
	// @gotags: badgerhold:"key"
	SegmentId string `protobuf:"bytes,1,opt,name=segment_id,json=segmentId,proto3" json:"segment_id,omitempty" badgerhold:"key"`
	// 当前片段在文件中的索引位置,从0开始
	// @gotags: badgerhold:"index"
	SegmentIndex int64 `protobuf:"varint,2,opt,name=segment_index,json=segmentIndex,proto3" json:"segment_index,omitempty" badgerhold:"index"`
	// 任务唯一标识
	// @gotags: badgerhold:"index"
	TaskId string `protobuf:"bytes,3,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty" badgerhold:"index"`
	// 当前片段大小,单位:字节
	Size_ int64 `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	// 当前片段的CRC32校验和,用于验证片段完整性
	// @gotags: badgerhold:"index"
	Crc32Checksum uint32 `protobuf:"varint,5,opt,name=crc32_checksum,json=crc32Checksum,proto3" json:"crc32_checksum,omitempty" badgerhold:"index"`
	// 当前片段的加密后内容
	SegmentContent []byte `protobuf:"bytes,6,opt,name=segment_content,json=segmentContent,proto3" json:"segment_content,omitempty"`
	// 是否为纠删码冗余分片
	IsRsCodes bool `protobuf:"varint,7,opt,name=is_rs_codes,json=isRsCodes,proto3" json:"is_rs_codes,omitempty"`
	// 分片的上传状态
	// @gotags: badgerhold:"index"
	Status SegmentUploadStatus `protobuf:"varint,8,opt,name=status,proto3,enum=pb.SegmentUploadStatus" json:"status,omitempty" badgerhold:"index"`
	// 需要过滤的节点ID列表，存储不希望分配任务的节点
	FilteredPeerIds      []string `protobuf:"bytes,9,rep,name=filtered_peer_ids,json=filteredPeerIds,proto3" json:"filtered_peer_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadSegmentRecord) Reset()         { *m = UploadSegmentRecord{} }
func (m *UploadSegmentRecord) String() string { return proto.CompactTextString(m) }
func (*UploadSegmentRecord) ProtoMessage()    {}
func (*UploadSegmentRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d5c292f53f1732c, []int{2}
}
func (m *UploadSegmentRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadSegmentRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadSegmentRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadSegmentRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadSegmentRecord.Merge(m, src)
}
func (m *UploadSegmentRecord) XXX_Size() int {
	return m.Size()
}
func (m *UploadSegmentRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadSegmentRecord.DiscardUnknown(m)
}

var xxx_messageInfo_UploadSegmentRecord proto.InternalMessageInfo

func (m *UploadSegmentRecord) GetSegmentId() string {
	if m != nil {
		return m.SegmentId
	}
	return ""
}

func (m *UploadSegmentRecord) GetSegmentIndex() int64 {
	if m != nil {
		return m.SegmentIndex
	}
	return 0
}

func (m *UploadSegmentRecord) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *UploadSegmentRecord) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *UploadSegmentRecord) GetCrc32Checksum() uint32 {
	if m != nil {
		return m.Crc32Checksum
	}
	return 0
}

func (m *UploadSegmentRecord) GetSegmentContent() []byte {
	if m != nil {
		return m.SegmentContent
	}
	return nil
}

func (m *UploadSegmentRecord) GetIsRsCodes() bool {
	if m != nil {
		return m.IsRsCodes
	}
	return false
}

func (m *UploadSegmentRecord) GetStatus() SegmentUploadStatus {
	if m != nil {
		return m.Status
	}
	return SegmentUploadStatus_SEGMENT_UPLOAD_STATUS_UNSPECIFIED
}

func (m *UploadSegmentRecord) GetFilteredPeerIds() []string {
	if m != nil {
		return m.FilteredPeerIds
	}
	return nil
}

// UploadChan 用于表示上传任务的通道信息，用于实时通信和状态更新
type UploadChan struct {
	// 任务唯一标识，通常是该片段数据的哈希值
	TaskId string `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// 上传任务是否完成的标志
	IsComplete bool `protobuf:"varint,2,opt,name=is_complete,json=isComplete,proto3" json:"is_complete,omitempty"`
	// 上传进度百分比，范围0-100
	UploadProgress int64 `protobuf:"varint,3,opt,name=upload_progress,json=uploadProgress,proto3" json:"upload_progress,omitempty"`
	// 文件总片段数量，数据片段+校验片段
	TotalShards int64 `protobuf:"varint,4,opt,name=total_shards,json=totalShards,proto3" json:"total_shards,omitempty"`
	// 文件片段唯一标识
	SegmentId string `protobuf:"bytes,5,opt,name=segment_id,json=segmentId,proto3" json:"segment_id,omitempty"`
	// 文件片段索引，表示该片段在文件中的顺序
	SegmentIndex int64 `protobuf:"varint,6,opt,name=segment_index,json=segmentIndex,proto3" json:"segment_index,omitempty"`
	// 文件片段大小，单位为字节
	SegmentSize int64 `protobuf:"varint,7,opt,name=segment_size,json=segmentSize,proto3" json:"segment_size,omitempty"`
	// 是否使用纠删码技术
	IsRsCodes bool `protobuf:"varint,8,opt,name=is_rs_codes,json=isRsCodes,proto3" json:"is_rs_codes,omitempty"`
	// 存储该文件片段的节点ID
	NodeId string `protobuf:"bytes,9,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// 上传完成时间的时间戳
	UploadTime           int64    `protobuf:"varint,10,opt,name=upload_time,json=uploadTime,proto3" json:"upload_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadChan) Reset()         { *m = UploadChan{} }
func (m *UploadChan) String() string { return proto.CompactTextString(m) }
func (*UploadChan) ProtoMessage()    {}
func (*UploadChan) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d5c292f53f1732c, []int{3}
}
func (m *UploadChan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadChan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadChan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadChan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadChan.Merge(m, src)
}
func (m *UploadChan) XXX_Size() int {
	return m.Size()
}
func (m *UploadChan) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadChan.DiscardUnknown(m)
}

var xxx_messageInfo_UploadChan proto.InternalMessageInfo

func (m *UploadChan) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *UploadChan) GetIsComplete() bool {
	if m != nil {
		return m.IsComplete
	}
	return false
}

func (m *UploadChan) GetUploadProgress() int64 {
	if m != nil {
		return m.UploadProgress
	}
	return 0
}

func (m *UploadChan) GetTotalShards() int64 {
	if m != nil {
		return m.TotalShards
	}
	return 0
}

func (m *UploadChan) GetSegmentId() string {
	if m != nil {
		return m.SegmentId
	}
	return ""
}

func (m *UploadChan) GetSegmentIndex() int64 {
	if m != nil {
		return m.SegmentIndex
	}
	return 0
}

func (m *UploadChan) GetSegmentSize() int64 {
	if m != nil {
		return m.SegmentSize
	}
	return 0
}

func (m *UploadChan) GetIsRsCodes() bool {
	if m != nil {
		return m.IsRsCodes
	}
	return false
}

func (m *UploadChan) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *UploadChan) GetUploadTime() int64 {
	if m != nil {
		return m.UploadTime
	}
	return 0
}

// UploadOperationInfo 表示上传操作的预处理或返回信息
type UploadOperationInfo struct {
	// 任务唯一标识，用于区分和管理不同的上传任务
	TaskId string `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// 文件路径，指定要上传的文件在本地系统中的位置
	FilePath string `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	// 文件唯一标识，用于在系统内部唯一区分文件，通常是哈希值或UUID
	FileId string `protobuf:"bytes,3,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	// 文件的基本元数据信息，包括文件名、大小等
	FileMeta *FileMeta `protobuf:"bytes,4,opt,name=file_meta,json=fileMeta,proto3" json:"file_meta,omitempty"`
	// 数据片段数量，表示文件被分割成的片段数
	DataShards int64 `protobuf:"varint,5,opt,name=data_shards,json=dataShards,proto3" json:"data_shards,omitempty"`
	// 校验片段数量，用于纠删码的冗余片段数
	ParityShards int64 `protobuf:"varint,6,opt,name=parity_shards,json=parityShards,proto3" json:"parity_shards,omitempty"`
	// 文件片段大小，单位为字节
	SegmentSize int64 `protobuf:"varint,7,opt,name=segment_size,json=segmentSize,proto3" json:"segment_size,omitempty"`
	// 奇偶校验片段占比，表示冗余数据占总数据的比例
	ParityRatio float64 `protobuf:"fixed64,8,opt,name=parity_ratio,json=parityRatio,proto3" json:"parity_ratio,omitempty"`
	// 文件开始上传的时间戳，记录上传操作开始的精确时间
	UploadTime int64 `protobuf:"varint,9,opt,name=upload_time,json=uploadTime,proto3" json:"upload_time,omitempty"`
	// 上传操作的状态，反映当前上传任务的进展情况
	Status               UploadStatus `protobuf:"varint,10,opt,name=status,proto3,enum=pb.UploadStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *UploadOperationInfo) Reset()         { *m = UploadOperationInfo{} }
func (m *UploadOperationInfo) String() string { return proto.CompactTextString(m) }
func (*UploadOperationInfo) ProtoMessage()    {}
func (*UploadOperationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d5c292f53f1732c, []int{4}
}
func (m *UploadOperationInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadOperationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadOperationInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadOperationInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadOperationInfo.Merge(m, src)
}
func (m *UploadOperationInfo) XXX_Size() int {
	return m.Size()
}
func (m *UploadOperationInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadOperationInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UploadOperationInfo proto.InternalMessageInfo

func (m *UploadOperationInfo) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *UploadOperationInfo) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *UploadOperationInfo) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *UploadOperationInfo) GetFileMeta() *FileMeta {
	if m != nil {
		return m.FileMeta
	}
	return nil
}

func (m *UploadOperationInfo) GetDataShards() int64 {
	if m != nil {
		return m.DataShards
	}
	return 0
}

func (m *UploadOperationInfo) GetParityShards() int64 {
	if m != nil {
		return m.ParityShards
	}
	return 0
}

func (m *UploadOperationInfo) GetSegmentSize() int64 {
	if m != nil {
		return m.SegmentSize
	}
	return 0
}

func (m *UploadOperationInfo) GetParityRatio() float64 {
	if m != nil {
		return m.ParityRatio
	}
	return 0
}

func (m *UploadOperationInfo) GetUploadTime() int64 {
	if m != nil {
		return m.UploadTime
	}
	return 0
}

func (m *UploadOperationInfo) GetStatus() UploadStatus {
	if m != nil {
		return m.Status
	}
	return UploadStatus_UPLOAD_STATUS_UNSPECIFIED
}

// FileAssetRecord 表示文件资产记录，用于存储在本地数据库中
type FileAssetRecord struct {
	// 文件唯一标识
	// @gotags: badgerhold:"key"
	FileId string `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty" badgerhold:"key"`
	// 文件内容的SHA256哈希值,用于校验文件完整性
	Sha256Hash []byte `protobuf:"bytes,2,opt,name=sha256_hash,json=sha256Hash,proto3" json:"sha256_hash,omitempty"`
	// 文件名称
	// @gotags: badgerhold:"index"
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty" badgerhold:"index"`
	// 文件大小（字节）
	Size_ int64 `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	// 文件扩展名，用于识别文件类型
	Extension string `protobuf:"bytes,5,opt,name=extension,proto3" json:"extension,omitempty"`
	// MIME类型,用于标识文件格式,如"application/pdf"
	ContentType string `protobuf:"bytes,6,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	// 所有者的公钥哈希，用于身份验证和访问控制
	// @gotags: badgerhold:"index"
	PubkeyHash []byte `protobuf:"bytes,7,opt,name=pubkey_hash,json=pubkeyHash,proto3" json:"pubkey_hash,omitempty" badgerhold:"index"`
	// 父级ID，用于构建文件层次结构
	ParentId int64 `protobuf:"varint,8,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty"`
	// 文件类型（0:文件, 1:文件夹）
	Type int64 `protobuf:"varint,9,opt,name=type,proto3" json:"type,omitempty"`
	// 标签，用于文件分类和检索
	Labels string `protobuf:"bytes,10,opt,name=labels,proto3" json:"labels,omitempty"`
	// 是否共享，标识文件是否可被其他用户访问
	IsShared bool `protobuf:"varint,11,opt,name=is_shared,json=isShared,proto3" json:"is_shared,omitempty"`
	// 共享金额，如果文件是付费共享，这里记录共享价格
	ShareAmount float64 `protobuf:"fixed64,12,opt,name=share_amount,json=shareAmount,proto3" json:"share_amount,omitempty"`
	// 上传时间（创建时间），记录文件首次上传的时间戳
	UploadTime int64 `protobuf:"varint,13,opt,name=upload_time,json=uploadTime,proto3" json:"upload_time,omitempty"`
	// 修改时间，记录文件最后一次被修改的时间戳
	ModTime              int64    `protobuf:"varint,14,opt,name=mod_time,json=modTime,proto3" json:"mod_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileAssetRecord) Reset()         { *m = FileAssetRecord{} }
func (m *FileAssetRecord) String() string { return proto.CompactTextString(m) }
func (*FileAssetRecord) ProtoMessage()    {}
func (*FileAssetRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d5c292f53f1732c, []int{5}
}
func (m *FileAssetRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileAssetRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileAssetRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileAssetRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileAssetRecord.Merge(m, src)
}
func (m *FileAssetRecord) XXX_Size() int {
	return m.Size()
}
func (m *FileAssetRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_FileAssetRecord.DiscardUnknown(m)
}

var xxx_messageInfo_FileAssetRecord proto.InternalMessageInfo

func (m *FileAssetRecord) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *FileAssetRecord) GetSha256Hash() []byte {
	if m != nil {
		return m.Sha256Hash
	}
	return nil
}

func (m *FileAssetRecord) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileAssetRecord) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *FileAssetRecord) GetExtension() string {
	if m != nil {
		return m.Extension
	}
	return ""
}

func (m *FileAssetRecord) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *FileAssetRecord) GetPubkeyHash() []byte {
	if m != nil {
		return m.PubkeyHash
	}
	return nil
}

func (m *FileAssetRecord) GetParentId() int64 {
	if m != nil {
		return m.ParentId
	}
	return 0
}

func (m *FileAssetRecord) GetType() int64 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *FileAssetRecord) GetLabels() string {
	if m != nil {
		return m.Labels
	}
	return ""
}

func (m *FileAssetRecord) GetIsShared() bool {
	if m != nil {
		return m.IsShared
	}
	return false
}

func (m *FileAssetRecord) GetShareAmount() float64 {
	if m != nil {
		return m.ShareAmount
	}
	return 0
}

func (m *FileAssetRecord) GetUploadTime() int64 {
	if m != nil {
		return m.UploadTime
	}
	return 0
}

func (m *FileAssetRecord) GetModTime() int64 {
	if m != nil {
		return m.ModTime
	}
	return 0
}

// UploadFilesSummaries 定义了上传任务的概要信息，用于快速展示任务状态
type UploadFilesSummaries struct {
	// 任务唯一标识，用于区分和管理不同的上传任务
	TaskId string `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// 文件名，显示正在上传的文件名称
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// 文件扩展名，用于识别文件类型
	Extension string `protobuf:"bytes,3,opt,name=extension,proto3" json:"extension,omitempty"`
	// 待上传总大小（字节），包括文件大小和奇偶校验片段大小
	TotalSize int64 `protobuf:"varint,4,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	// 上传状态，反映当前上传任务的进展情况
	UploadStatus UploadStatus `protobuf:"varint,5,opt,name=upload_status,json=uploadStatus,proto3,enum=pb.UploadStatus" json:"upload_status,omitempty"`
	// 上传进度（百分比），范围0-100，表示已上传的数据量占总数据量的比例
	Progress             int64    `protobuf:"varint,6,opt,name=progress,proto3" json:"progress,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadFilesSummaries) Reset()         { *m = UploadFilesSummaries{} }
func (m *UploadFilesSummaries) String() string { return proto.CompactTextString(m) }
func (*UploadFilesSummaries) ProtoMessage()    {}
func (*UploadFilesSummaries) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d5c292f53f1732c, []int{6}
}
func (m *UploadFilesSummaries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadFilesSummaries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadFilesSummaries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadFilesSummaries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadFilesSummaries.Merge(m, src)
}
func (m *UploadFilesSummaries) XXX_Size() int {
	return m.Size()
}
func (m *UploadFilesSummaries) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadFilesSummaries.DiscardUnknown(m)
}

var xxx_messageInfo_UploadFilesSummaries proto.InternalMessageInfo

func (m *UploadFilesSummaries) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *UploadFilesSummaries) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UploadFilesSummaries) GetExtension() string {
	if m != nil {
		return m.Extension
	}
	return ""
}

func (m *UploadFilesSummaries) GetTotalSize() int64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *UploadFilesSummaries) GetUploadStatus() UploadStatus {
	if m != nil {
		return m.UploadStatus
	}
	return UploadStatus_UPLOAD_STATUS_UNSPECIFIED
}

func (m *UploadFilesSummaries) GetProgress() int64 {
	if m != nil {
		return m.Progress
	}
	return 0
}

// UploadPubSubDeleteFileSegmentRequest 上传订阅删除文件信息请求
type UploadPubSubDeleteFileSegmentRequest struct {
	// 文件唯一标识，用于在系统内部唯一区分文件，通常是哈希值或UUID
	FileId string `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	// 所有者的公钥哈希，用于身份验证和访问控制
	PubkeyHash           []byte   `protobuf:"bytes,3,opt,name=pubkey_hash,json=pubkeyHash,proto3" json:"pubkey_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadPubSubDeleteFileSegmentRequest) Reset()         { *m = UploadPubSubDeleteFileSegmentRequest{} }
func (m *UploadPubSubDeleteFileSegmentRequest) String() string { return proto.CompactTextString(m) }
func (*UploadPubSubDeleteFileSegmentRequest) ProtoMessage()    {}
func (*UploadPubSubDeleteFileSegmentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d5c292f53f1732c, []int{7}
}
func (m *UploadPubSubDeleteFileSegmentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadPubSubDeleteFileSegmentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadPubSubDeleteFileSegmentRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadPubSubDeleteFileSegmentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadPubSubDeleteFileSegmentRequest.Merge(m, src)
}
func (m *UploadPubSubDeleteFileSegmentRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadPubSubDeleteFileSegmentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadPubSubDeleteFileSegmentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadPubSubDeleteFileSegmentRequest proto.InternalMessageInfo

func (m *UploadPubSubDeleteFileSegmentRequest) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *UploadPubSubDeleteFileSegmentRequest) GetPubkeyHash() []byte {
	if m != nil {
		return m.PubkeyHash
	}
	return nil
}

func init() {
	proto.RegisterEnum("pb.UploadStatus", UploadStatus_name, UploadStatus_value)
	proto.RegisterEnum("pb.SegmentUploadStatus", SegmentUploadStatus_name, SegmentUploadStatus_value)
	proto.RegisterType((*FileSecurity)(nil), "pb.FileSecurity")
	proto.RegisterType((*UploadFileRecord)(nil), "pb.UploadFileRecord")
	proto.RegisterMapType((map[int64]*HashTable)(nil), "pb.UploadFileRecord.SliceTableEntry")
	proto.RegisterType((*UploadSegmentRecord)(nil), "pb.UploadSegmentRecord")
	proto.RegisterType((*UploadChan)(nil), "pb.UploadChan")
	proto.RegisterType((*UploadOperationInfo)(nil), "pb.UploadOperationInfo")
	proto.RegisterType((*FileAssetRecord)(nil), "pb.FileAssetRecord")
	proto.RegisterType((*UploadFilesSummaries)(nil), "pb.UploadFilesSummaries")
	proto.RegisterType((*UploadPubSubDeleteFileSegmentRequest)(nil), "pb.UploadPubSubDeleteFileSegmentRequest")
}

func init() { proto.RegisterFile("pb/upload.proto", fileDescriptor_6d5c292f53f1732c) }

var fileDescriptor_6d5c292f53f1732c = []byte{
	// 1289 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xdd, 0x72, 0xdb, 0x44,
	0x14, 0x46, 0x56, 0xe2, 0x58, 0x47, 0x76, 0x62, 0xb6, 0xa5, 0x71, 0xd3, 0xe6, 0xbf, 0x1d, 0x4c,
	0x2f, 0xd2, 0x19, 0x77, 0xca, 0x30, 0xdc, 0x19, 0x5b, 0x2d, 0x1e, 0x52, 0xc7, 0x23, 0x39, 0x33,
	0x70, 0x25, 0xd6, 0xd2, 0xa6, 0xd6, 0xc4, 0x96, 0x84, 0x76, 0x5d, 0x6a, 0x9e, 0x82, 0x6b, 0x9e,
	0x82, 0x5b, 0xde, 0x80, 0x4b, 0x66, 0xfa, 0x02, 0x4c, 0x2f, 0xb8, 0xe6, 0x11, 0x98, 0x3d, 0xbb,
	0x8a, 0x1d, 0xc5, 0x29, 0x70, 0xb7, 0xe7, 0x3b, 0x67, 0x57, 0x67, 0xbf, 0x6f, 0xf7, 0x5b, 0xc1,
	0x56, 0x3a, 0x7a, 0x3a, 0x4b, 0x27, 0x09, 0x0d, 0x4f, 0xd2, 0x2c, 0x11, 0x09, 0x29, 0xa5, 0xa3,
	0x9d, 0x7a, 0x3a, 0x7a, 0xca, 0x45, 0x92, 0xd1, 0xd7, 0x4c, 0xa1, 0x47, 0xbf, 0x1a, 0x50, 0x7d,
	0x11, 0x4d, 0x98, 0xc7, 0x82, 0x59, 0x16, 0x89, 0x39, 0xb9, 0x07, 0x65, 0xce, 0x82, 0x8c, 0x89,
	0x86, 0x71, 0x60, 0x34, 0xab, 0xae, 0x8e, 0xc8, 0x63, 0xd8, 0x64, 0x71, 0x90, 0xcd, 0x53, 0x11,
	0x25, 0xb1, 0x7f, 0xc9, 0xe6, 0x8d, 0xd2, 0x81, 0xd9, 0xac, 0xba, 0xb5, 0x05, 0xfa, 0x0d, 0x9b,
	0x93, 0x5d, 0x80, 0xe4, 0xc7, 0x98, 0x65, 0x7e, 0x9a, 0x45, 0x6f, 0x1a, 0x26, 0x2e, 0x61, 0x21,
	0x32, 0xc8, 0xa2, 0x37, 0xe4, 0x10, 0xaa, 0x69, 0x2b, 0xbd, 0x1c, 0xfb, 0x3c, 0xc8, 0xa2, 0x54,
	0x34, 0xd6, 0xb0, 0xc0, 0x46, 0xcc, 0x43, 0x88, 0xec, 0x03, 0x86, 0x79, 0xc5, 0x3a, 0x56, 0x80,
	0x84, 0x54, 0xc1, 0xd1, 0x6f, 0x26, 0xd4, 0xcf, 0x71, 0x67, 0xb2, 0x71, 0x97, 0x05, 0x49, 0x16,
	0x92, 0x6d, 0xd8, 0x10, 0x94, 0x5f, 0xfa, 0x51, 0x88, 0x7d, 0x5b, 0x6e, 0x59, 0x86, 0x3d, 0x4c,
	0x5c, 0x44, 0x13, 0x26, 0x13, 0x25, 0x95, 0x90, 0x61, 0x2f, 0x24, 0x04, 0xd6, 0x52, 0x2a, 0xc6,
	0xd8, 0xa3, 0xe5, 0xe2, 0x98, 0x7c, 0x06, 0x16, 0x16, 0x4f, 0x99, 0xa0, 0xd8, 0x9b, 0xdd, 0xaa,
	0x9e, 0xa4, 0xa3, 0x13, 0xf9, 0xa1, 0x57, 0x4c, 0x50, 0xb7, 0x72, 0xa1, 0x47, 0xe4, 0x39, 0xd4,
	0xb0, 0x94, 0x6b, 0xe2, 0xb0, 0x51, 0xbb, 0x55, 0xcf, 0xcb, 0x73, 0x42, 0xdd, 0xea, 0xc5, 0x32,
	0xbd, 0x0e, 0xd8, 0x7c, 0x12, 0x05, 0xcc, 0x17, 0x74, 0x34, 0x61, 0x8d, 0xf2, 0x81, 0xd9, 0xb4,
	0x5b, 0x8f, 0xe4, 0xa4, 0xe2, 0x96, 0x4e, 0x3c, 0x59, 0x37, 0x94, 0x65, 0x4e, 0x2c, 0xb2, 0xb9,
	0x0b, 0xfc, 0x0a, 0x90, 0x34, 0x73, 0x41, 0x33, 0xc1, 0x42, 0x9f, 0x8a, 0xc6, 0xc6, 0x81, 0xd1,
	0x34, 0x5d, 0x4b, 0x23, 0x6d, 0xe4, 0xf0, 0x22, 0x8a, 0x23, 0x3e, 0x56, 0xf9, 0x0a, 0xe6, 0x21,
	0x87, 0xda, 0x82, 0x34, 0xa1, 0xcc, 0x05, 0x15, 0x33, 0xde, 0xb0, 0x0e, 0x8c, 0xe6, 0xa6, 0x6a,
	0x5b, 0x75, 0xe0, 0x21, 0xee, 0xea, 0xfc, 0xce, 0x29, 0x6c, 0x15, 0x1a, 0x21, 0x75, 0x30, 0xa5,
	0xfe, 0x06, 0xae, 0x2a, 0x87, 0xe4, 0x18, 0xd6, 0xdf, 0xd0, 0xc9, 0x8c, 0x21, 0xc5, 0x76, 0xab,
	0x26, 0x57, 0xfb, 0x9a, 0xf2, 0x31, 0x4e, 0x72, 0x55, 0xee, 0xcb, 0xd2, 0x17, 0xc6, 0xd1, 0xbb,
	0x12, 0xdc, 0xd1, 0x9f, 0x61, 0xaf, 0xa7, 0x2c, 0x16, 0x5a, 0x3e, 0xb9, 0x1f, 0x05, 0x2c, 0x14,
	0xb4, 0x34, 0xd2, 0x0b, 0xc9, 0x31, 0xd4, 0xae, 0xd2, 0x71, 0xc8, 0xde, 0xe2, 0x77, 0x4c, 0xb7,
	0x9a, 0x57, 0x48, 0x6c, 0xf9, 0x08, 0x98, 0xd7, 0x8e, 0x00, 0x81, 0x35, 0x1e, 0xfd, 0xc4, 0x50,
	0x50, 0xd3, 0xc5, 0xb1, 0x3c, 0xce, 0x41, 0x16, 0x3c, 0x6b, 0xf9, 0xc1, 0x98, 0x05, 0x97, 0x7c,
	0x36, 0x45, 0xfd, 0x6a, 0x6e, 0x0d, 0xd1, 0x8e, 0x06, 0xc9, 0xa7, 0xb0, 0x95, 0x7f, 0x38, 0x48,
	0x62, 0xc1, 0x62, 0xd1, 0x28, 0xe3, 0x81, 0xdc, 0xd4, 0x70, 0x47, 0xa1, 0x64, 0x0f, 0xec, 0x88,
	0xfb, 0x19, 0xf7, 0x83, 0x24, 0x64, 0x1c, 0x15, 0xa9, 0xb8, 0x56, 0xc4, 0x5d, 0xde, 0x91, 0x00,
	0x79, 0x7a, 0x45, 0x78, 0x05, 0x09, 0xdf, 0x96, 0x14, 0x69, 0x0e, 0x56, 0xf1, 0x4e, 0x9e, 0xc0,
	0xc7, 0x17, 0xd1, 0x44, 0xb0, 0x8c, 0x85, 0x7e, 0xca, 0x58, 0xe6, 0x47, 0xa1, 0x14, 0xcb, 0x6c,
	0x5a, 0xee, 0x56, 0x9e, 0x18, 0x30, 0x96, 0xf5, 0x42, 0x2e, 0x59, 0x05, 0xb5, 0x48, 0x67, 0x4c,
	0xe3, 0xdb, 0xef, 0xc2, 0x3e, 0x36, 0x19, 0x24, 0xd3, 0x74, 0xc2, 0x84, 0x12, 0xab, 0xe2, 0x42,
	0xc4, 0x3b, 0x1a, 0x91, 0xdb, 0x55, 0x9e, 0xe1, 0xa7, 0x59, 0xf2, 0x3a, 0x63, 0x9c, 0x23, 0x95,
	0xa6, 0xbb, 0xa9, 0xe0, 0x81, 0x46, 0xe5, 0x3d, 0x16, 0x89, 0xa0, 0x13, 0x9f, 0x8f, 0x69, 0x16,
	0x72, 0x4d, 0xad, 0x8d, 0x98, 0x87, 0x50, 0x41, 0xd2, 0xf5, 0x7f, 0x95, 0xb4, 0xbc, 0x42, 0xd2,
	0x43, 0xc8, 0x63, 0x1f, 0x15, 0x54, 0x07, 0xdd, 0xd6, 0x98, 0x27, 0x85, 0x2c, 0x10, 0x5f, 0x29,
	0x12, 0xbf, 0x0d, 0x1b, 0x71, 0x12, 0xe2, 0xfd, 0xb7, 0x14, 0x19, 0x32, 0x54, 0x64, 0xe8, 0xbd,
	0x8a, 0x68, 0xca, 0x1a, 0xa0, 0xee, 0x88, 0x82, 0x86, 0xd1, 0x94, 0x1d, 0xfd, 0x75, 0x75, 0x56,
	0xcf, 0x52, 0x96, 0x51, 0xe9, 0x70, 0xbd, 0xf8, 0x22, 0xb9, 0x9d, 0xde, 0x07, 0xda, 0x3d, 0xd0,
	0x56, 0x94, 0xd9, 0xa0, 0x5f, 0x0c, 0xa4, 0xb5, 0x2c, 0xf9, 0x90, 0x79, 0xcd, 0x87, 0xfe, 0x87,
	0xe7, 0xec, 0x83, 0x1d, 0x52, 0x41, 0x73, 0xd2, 0xd7, 0x55, 0xcb, 0x12, 0xd2, 0x9c, 0x1f, 0x43,
	0x2d, 0xa5, 0xd2, 0x67, 0xf2, 0x12, 0x4d, 0xaa, 0x02, 0x75, 0xd1, 0x7f, 0x20, 0x55, 0xda, 0xb4,
	0x5a, 0x07, 0xf7, 0x8d, 0xac, 0x1a, 0xae, 0xad, 0x30, 0x57, 0x42, 0x45, 0xfa, 0xac, 0x22, 0x7d,
	0x4b, 0x16, 0x03, 0x1f, 0xb6, 0x98, 0xa3, 0x5f, 0x4c, 0xd8, 0x92, 0xbb, 0x6d, 0x73, 0xce, 0xc4,
	0xc2, 0xcf, 0x73, 0xba, 0x8c, 0x6b, 0x74, 0xed, 0x83, 0xcd, 0xc7, 0xb4, 0xf5, 0xfc, 0x73, 0x7f,
	0x4c, 0xb9, 0xa2, 0xb9, 0xea, 0x82, 0x82, 0xa4, 0xe5, 0xc8, 0xdb, 0x1e, 0xd3, 0x29, 0xcb, 0x7d,
	0x5d, 0x8e, 0x57, 0x3a, 0xc0, 0x43, 0xb0, 0xd8, 0x5b, 0xc1, 0x62, 0x1e, 0x25, 0x71, 0x7e, 0x3c,
	0xaf, 0x00, 0xc9, 0x80, 0xbe, 0xf0, 0xbe, 0x98, 0xa7, 0x0c, 0x89, 0xb4, 0x5c, 0x5b, 0x63, 0xc3,
	0x79, 0xca, 0xf0, 0xa1, 0x9a, 0x8d, 0x2e, 0xd9, 0x5c, 0x75, 0xb2, 0xa1, 0x1f, 0x2a, 0x84, 0xb0,
	0x93, 0x07, 0x60, 0xa5, 0x34, 0xd3, 0x17, 0x40, 0x79, 0x70, 0x45, 0x01, 0xca, 0x94, 0x70, 0x61,
	0x45, 0x1c, 0x8e, 0xe5, 0xdb, 0x3b, 0xa1, 0x23, 0x36, 0x51, 0x94, 0x59, 0xae, 0x8e, 0xe4, 0x42,
	0x11, 0x47, 0x49, 0x59, 0xd8, 0xb0, 0xf1, 0x84, 0x57, 0x22, 0xee, 0x61, 0x8c, 0x72, 0xca, 0x91,
	0x4f, 0xa7, 0xc9, 0x2c, 0x16, 0x8d, 0xaa, 0xd2, 0x0a, 0xb1, 0x36, 0x42, 0x45, 0xad, 0x6a, 0x37,
	0xb4, 0xba, 0x0f, 0x95, 0x69, 0xa2, 0xb3, 0x9b, 0x98, 0xdd, 0x98, 0x26, 0xea, 0x16, 0xbc, 0x33,
	0xe0, 0xee, 0xe2, 0x69, 0xe2, 0xde, 0x6c, 0x3a, 0xa5, 0x59, 0xa4, 0x2e, 0xd6, 0xea, 0x6b, 0x90,
	0x0b, 0x50, 0x5a, 0x12, 0xe0, 0x1a, 0xd9, 0x66, 0x91, 0xec, 0x5d, 0x00, 0xed, 0x26, 0x0b, 0x91,
	0x2c, 0xe5, 0x25, 0x52, 0xa9, 0xe7, 0x50, 0xd3, 0xed, 0xeb, 0x03, 0xb5, 0x7e, 0xcb, 0x81, 0xaa,
	0xce, 0x96, 0x22, 0xb2, 0x03, 0x95, 0x2b, 0x17, 0x2b, 0x6b, 0xf6, 0x75, 0x7c, 0xf4, 0x3d, 0x3c,
	0x52, 0x33, 0x07, 0xb3, 0x91, 0x37, 0x1b, 0x75, 0x99, 0xb4, 0x3f, 0xf5, 0x6c, 0xeb, 0x67, 0xe9,
	0x87, 0x19, 0xe3, 0xe2, 0xf6, 0xbf, 0x87, 0x82, 0xf8, 0x66, 0x51, 0xfc, 0x27, 0x3f, 0x97, 0xa0,
	0xba, 0xdc, 0x1c, 0xd9, 0x85, 0xfb, 0xe7, 0x83, 0xd3, 0xb3, 0x76, 0xd7, 0xf7, 0x86, 0xed, 0xe1,
	0xb9, 0xe7, 0x9f, 0xf7, 0xbd, 0x81, 0xd3, 0xe9, 0xbd, 0xe8, 0x39, 0xdd, 0xfa, 0x47, 0x64, 0x07,
	0xee, 0x5d, 0x4f, 0x3b, 0xfd, 0xce, 0x59, 0xb7, 0xd7, 0x7f, 0x59, 0x37, 0xc8, 0x7d, 0xf8, 0xe4,
	0x7a, 0x6e, 0xe0, 0xf4, 0x31, 0x55, 0x22, 0x0f, 0x60, 0xbb, 0xb0, 0x2a, 0x46, 0x32, 0x69, 0x92,
	0x06, 0xdc, 0x2d, 0xcc, 0x6b, 0x9f, 0x7b, 0x4e, 0xb7, 0xbe, 0x76, 0x73, 0x5a, 0xe7, 0xec, 0xd5,
	0xe0, 0xd4, 0x19, 0x3a, 0xdd, 0xfa, 0xfa, 0xcd, 0x69, 0x2f, 0xda, 0xbd, 0x53, 0xa7, 0x5b, 0x2f,
	0xdf, 0x6c, 0xb2, 0xd3, 0xee, 0x77, 0x1c, 0x99, 0xdb, 0x20, 0x07, 0xf0, 0xb0, 0x30, 0xab, 0x77,
	0xea, 0xf8, 0xce, 0xb7, 0x1d, 0x67, 0x30, 0xec, 0x9d, 0xf5, 0xeb, 0x95, 0x27, 0x7f, 0x1b, 0x70,
	0x67, 0xc5, 0x93, 0x47, 0x1e, 0xc3, 0xa1, 0xe7, 0xbc, 0x7c, 0xe5, 0xf4, 0x87, 0xfe, 0x87, 0x18,
	0x3a, 0x86, 0xfd, 0xd5, 0x65, 0xfd, 0xb3, 0xa1, 0xef, 0x3a, 0xed, 0xee, 0x77, 0x75, 0x83, 0x1c,
	0xc2, 0xee, 0xea, 0xa2, 0x05, 0x65, 0xb7, 0xae, 0xb3, 0x4c, 0xdd, 0xad, 0x45, 0x0b, 0xa2, 0xd6,
	0xe4, 0x96, 0x57, 0x17, 0x69, 0xc2, 0xd6, 0xbf, 0xaa, 0xfe, 0xfe, 0x7e, 0xcf, 0xf8, 0xe3, 0xfd,
	0x9e, 0xf1, 0xe7, 0xfb, 0x3d, 0x63, 0x54, 0xc6, 0x7f, 0xee, 0x67, 0xff, 0x04, 0x00, 0x00, 0xff,
	0xff, 0x13, 0xea, 0xe4, 0xcc, 0x9c, 0x0b, 0x00, 0x00,
}

func (m *FileSecurity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileSecurity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileSecurity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.P2PkScript) > 0 {
		i -= len(m.P2PkScript)
		copy(dAtA[i:], m.P2PkScript)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.P2PkScript)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.P2PkhScript) > 0 {
		i -= len(m.P2PkhScript)
		copy(dAtA[i:], m.P2PkhScript)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.P2PkhScript)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OwnerPriv) > 0 {
		i -= len(m.OwnerPriv)
		copy(dAtA[i:], m.OwnerPriv)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.OwnerPriv)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EncryptionKey) > 0 {
		for iNdEx := len(m.EncryptionKey) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EncryptionKey[iNdEx])
			copy(dAtA[i:], m.EncryptionKey[iNdEx])
			i = encodeVarintUpload(dAtA, i, uint64(len(m.EncryptionKey[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Secret) > 0 {
		i -= len(m.Secret)
		copy(dAtA[i:], m.Secret)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.Secret)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadFileRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadFileRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadFileRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x48
	}
	if m.FinishedAt != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.FinishedAt))
		i--
		dAtA[i] = 0x40
	}
	if m.StartedAt != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.StartedAt))
		i--
		dAtA[i] = 0x38
	}
	if len(m.SliceTable) > 0 {
		for k := range m.SliceTable {
			v := m.SliceTable[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintUpload(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintUpload(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintUpload(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.FileSecurity != nil {
		{
			size, err := m.FileSecurity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpload(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.FileMeta != nil {
		{
			size, err := m.FileMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpload(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadSegmentRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadSegmentRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadSegmentRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FilteredPeerIds) > 0 {
		for iNdEx := len(m.FilteredPeerIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FilteredPeerIds[iNdEx])
			copy(dAtA[i:], m.FilteredPeerIds[iNdEx])
			i = encodeVarintUpload(dAtA, i, uint64(len(m.FilteredPeerIds[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Status != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x40
	}
	if m.IsRsCodes {
		i--
		if m.IsRsCodes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.SegmentContent) > 0 {
		i -= len(m.SegmentContent)
		copy(dAtA[i:], m.SegmentContent)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.SegmentContent)))
		i--
		dAtA[i] = 0x32
	}
	if m.Crc32Checksum != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.Crc32Checksum))
		i--
		dAtA[i] = 0x28
	}
	if m.Size_ != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SegmentIndex != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.SegmentIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SegmentId) > 0 {
		i -= len(m.SegmentId)
		copy(dAtA[i:], m.SegmentId)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.SegmentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadChan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadChan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadChan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UploadTime != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.UploadTime))
		i--
		dAtA[i] = 0x50
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0x4a
	}
	if m.IsRsCodes {
		i--
		if m.IsRsCodes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.SegmentSize != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.SegmentSize))
		i--
		dAtA[i] = 0x38
	}
	if m.SegmentIndex != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.SegmentIndex))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SegmentId) > 0 {
		i -= len(m.SegmentId)
		copy(dAtA[i:], m.SegmentId)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.SegmentId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.TotalShards != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.TotalShards))
		i--
		dAtA[i] = 0x20
	}
	if m.UploadProgress != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.UploadProgress))
		i--
		dAtA[i] = 0x18
	}
	if m.IsComplete {
		i--
		if m.IsComplete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadOperationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadOperationInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadOperationInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x50
	}
	if m.UploadTime != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.UploadTime))
		i--
		dAtA[i] = 0x48
	}
	if m.ParityRatio != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ParityRatio))))
		i--
		dAtA[i] = 0x41
	}
	if m.SegmentSize != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.SegmentSize))
		i--
		dAtA[i] = 0x38
	}
	if m.ParityShards != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.ParityShards))
		i--
		dAtA[i] = 0x30
	}
	if m.DataShards != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.DataShards))
		i--
		dAtA[i] = 0x28
	}
	if m.FileMeta != nil {
		{
			size, err := m.FileMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUpload(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FilePath) > 0 {
		i -= len(m.FilePath)
		copy(dAtA[i:], m.FilePath)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.FilePath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileAssetRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileAssetRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileAssetRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ModTime != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.ModTime))
		i--
		dAtA[i] = 0x70
	}
	if m.UploadTime != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.UploadTime))
		i--
		dAtA[i] = 0x68
	}
	if m.ShareAmount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ShareAmount))))
		i--
		dAtA[i] = 0x61
	}
	if m.IsShared {
		i--
		if m.IsShared {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.Labels) > 0 {
		i -= len(m.Labels)
		copy(dAtA[i:], m.Labels)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.Labels)))
		i--
		dAtA[i] = 0x52
	}
	if m.Type != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x48
	}
	if m.ParentId != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.ParentId))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PubkeyHash) > 0 {
		i -= len(m.PubkeyHash)
		copy(dAtA[i:], m.PubkeyHash)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.PubkeyHash)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Extension) > 0 {
		i -= len(m.Extension)
		copy(dAtA[i:], m.Extension)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.Extension)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Size_ != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sha256Hash) > 0 {
		i -= len(m.Sha256Hash)
		copy(dAtA[i:], m.Sha256Hash)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.Sha256Hash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadFilesSummaries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadFilesSummaries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadFilesSummaries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Progress != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.Progress))
		i--
		dAtA[i] = 0x30
	}
	if m.UploadStatus != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.UploadStatus))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalSize != 0 {
		i = encodeVarintUpload(dAtA, i, uint64(m.TotalSize))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Extension) > 0 {
		i -= len(m.Extension)
		copy(dAtA[i:], m.Extension)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.Extension)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadPubSubDeleteFileSegmentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadPubSubDeleteFileSegmentRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadPubSubDeleteFileSegmentRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PubkeyHash) > 0 {
		i -= len(m.PubkeyHash)
		copy(dAtA[i:], m.PubkeyHash)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.PubkeyHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintUpload(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func encodeVarintUpload(dAtA []byte, offset int, v uint64) int {
	offset -= sovUpload(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FileSecurity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	if len(m.EncryptionKey) > 0 {
		for _, b := range m.EncryptionKey {
			l = len(b)
			n += 1 + l + sovUpload(uint64(l))
		}
	}
	l = len(m.OwnerPriv)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	l = len(m.P2PkhScript)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	l = len(m.P2PkScript)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadFileRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	if m.FileMeta != nil {
		l = m.FileMeta.Size()
		n += 1 + l + sovUpload(uint64(l))
	}
	if m.FileSecurity != nil {
		l = m.FileSecurity.Size()
		n += 1 + l + sovUpload(uint64(l))
	}
	if len(m.SliceTable) > 0 {
		for k, v := range m.SliceTable {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovUpload(uint64(l))
			}
			mapEntrySize := 1 + sovUpload(uint64(k)) + l
			n += mapEntrySize + 1 + sovUpload(uint64(mapEntrySize))
		}
	}
	if m.StartedAt != 0 {
		n += 1 + sovUpload(uint64(m.StartedAt))
	}
	if m.FinishedAt != 0 {
		n += 1 + sovUpload(uint64(m.FinishedAt))
	}
	if m.Status != 0 {
		n += 1 + sovUpload(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadSegmentRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SegmentId)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	if m.SegmentIndex != 0 {
		n += 1 + sovUpload(uint64(m.SegmentIndex))
	}
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovUpload(uint64(m.Size_))
	}
	if m.Crc32Checksum != 0 {
		n += 1 + sovUpload(uint64(m.Crc32Checksum))
	}
	l = len(m.SegmentContent)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	if m.IsRsCodes {
		n += 2
	}
	if m.Status != 0 {
		n += 1 + sovUpload(uint64(m.Status))
	}
	if len(m.FilteredPeerIds) > 0 {
		for _, s := range m.FilteredPeerIds {
			l = len(s)
			n += 1 + l + sovUpload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadChan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	if m.IsComplete {
		n += 2
	}
	if m.UploadProgress != 0 {
		n += 1 + sovUpload(uint64(m.UploadProgress))
	}
	if m.TotalShards != 0 {
		n += 1 + sovUpload(uint64(m.TotalShards))
	}
	l = len(m.SegmentId)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	if m.SegmentIndex != 0 {
		n += 1 + sovUpload(uint64(m.SegmentIndex))
	}
	if m.SegmentSize != 0 {
		n += 1 + sovUpload(uint64(m.SegmentSize))
	}
	if m.IsRsCodes {
		n += 2
	}
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	if m.UploadTime != 0 {
		n += 1 + sovUpload(uint64(m.UploadTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadOperationInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	if m.FileMeta != nil {
		l = m.FileMeta.Size()
		n += 1 + l + sovUpload(uint64(l))
	}
	if m.DataShards != 0 {
		n += 1 + sovUpload(uint64(m.DataShards))
	}
	if m.ParityShards != 0 {
		n += 1 + sovUpload(uint64(m.ParityShards))
	}
	if m.SegmentSize != 0 {
		n += 1 + sovUpload(uint64(m.SegmentSize))
	}
	if m.ParityRatio != 0 {
		n += 9
	}
	if m.UploadTime != 0 {
		n += 1 + sovUpload(uint64(m.UploadTime))
	}
	if m.Status != 0 {
		n += 1 + sovUpload(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileAssetRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	l = len(m.Sha256Hash)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovUpload(uint64(m.Size_))
	}
	l = len(m.Extension)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	l = len(m.PubkeyHash)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	if m.ParentId != 0 {
		n += 1 + sovUpload(uint64(m.ParentId))
	}
	if m.Type != 0 {
		n += 1 + sovUpload(uint64(m.Type))
	}
	l = len(m.Labels)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	if m.IsShared {
		n += 2
	}
	if m.ShareAmount != 0 {
		n += 9
	}
	if m.UploadTime != 0 {
		n += 1 + sovUpload(uint64(m.UploadTime))
	}
	if m.ModTime != 0 {
		n += 1 + sovUpload(uint64(m.ModTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadFilesSummaries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	l = len(m.Extension)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovUpload(uint64(m.TotalSize))
	}
	if m.UploadStatus != 0 {
		n += 1 + sovUpload(uint64(m.UploadStatus))
	}
	if m.Progress != 0 {
		n += 1 + sovUpload(uint64(m.Progress))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadPubSubDeleteFileSegmentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	l = len(m.PubkeyHash)
	if l > 0 {
		n += 1 + l + sovUpload(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovUpload(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozUpload(x uint64) (n int) {
	return sovUpload(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FileSecurity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileSecurity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileSecurity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = append(m.Secret[:0], dAtA[iNdEx:postIndex]...)
			if m.Secret == nil {
				m.Secret = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionKey = append(m.EncryptionKey, make([]byte, postIndex-iNdEx))
			copy(m.EncryptionKey[len(m.EncryptionKey)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerPriv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerPriv = append(m.OwnerPriv[:0], dAtA[iNdEx:postIndex]...)
			if m.OwnerPriv == nil {
				m.OwnerPriv = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P2PkhScript", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.P2PkhScript = append(m.P2PkhScript[:0], dAtA[iNdEx:postIndex]...)
			if m.P2PkhScript == nil {
				m.P2PkhScript = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P2PkScript", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.P2PkScript = append(m.P2PkScript[:0], dAtA[iNdEx:postIndex]...)
			if m.P2PkScript == nil {
				m.P2PkScript = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadFileRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadFileRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadFileRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileMeta == nil {
				m.FileMeta = &FileMeta{}
			}
			if err := m.FileMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSecurity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileSecurity == nil {
				m.FileSecurity = &FileSecurity{}
			}
			if err := m.FileSecurity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SliceTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SliceTable == nil {
				m.SliceTable = make(map[int64]*HashTable)
			}
			var mapkey int64
			var mapvalue *HashTable
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUpload
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowUpload
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowUpload
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthUpload
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthUpload
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &HashTable{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipUpload(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthUpload
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SliceTable[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			m.StartedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishedAt", wireType)
			}
			m.FinishedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinishedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= UploadStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadSegmentRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadSegmentRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadSegmentRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SegmentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentIndex", wireType)
			}
			m.SegmentIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentIndex |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc32Checksum", wireType)
			}
			m.Crc32Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crc32Checksum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentContent", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SegmentContent = append(m.SegmentContent[:0], dAtA[iNdEx:postIndex]...)
			if m.SegmentContent == nil {
				m.SegmentContent = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRsCodes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRsCodes = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SegmentUploadStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilteredPeerIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilteredPeerIds = append(m.FilteredPeerIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadChan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadChan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadChan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsComplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsComplete = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadProgress", wireType)
			}
			m.UploadProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadProgress |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalShards", wireType)
			}
			m.TotalShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalShards |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SegmentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentIndex", wireType)
			}
			m.SegmentIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentIndex |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentSize", wireType)
			}
			m.SegmentSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRsCodes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRsCodes = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTime", wireType)
			}
			m.UploadTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadOperationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadOperationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadOperationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileMeta == nil {
				m.FileMeta = &FileMeta{}
			}
			if err := m.FileMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataShards", wireType)
			}
			m.DataShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataShards |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParityShards", wireType)
			}
			m.ParityShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParityShards |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentSize", wireType)
			}
			m.SegmentSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParityRatio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ParityRatio = float64(math.Float64frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTime", wireType)
			}
			m.UploadTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= UploadStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileAssetRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileAssetRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileAssetRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha256Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha256Hash = append(m.Sha256Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Sha256Hash == nil {
				m.Sha256Hash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubkeyHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubkeyHash = append(m.PubkeyHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PubkeyHash == nil {
				m.PubkeyHash = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			m.ParentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShared", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShared = bool(v != 0)
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ShareAmount = float64(math.Float64frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTime", wireType)
			}
			m.UploadTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModTime", wireType)
			}
			m.ModTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadFilesSummaries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadFilesSummaries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadFilesSummaries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadStatus", wireType)
			}
			m.UploadStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadStatus |= UploadStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			m.Progress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Progress |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadPubSubDeleteFileSegmentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadPubSubDeleteFileSegmentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadPubSubDeleteFileSegmentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubkeyHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUpload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthUpload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubkeyHash = append(m.PubkeyHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PubkeyHash == nil {
				m.PubkeyHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipUpload(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowUpload
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUpload
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthUpload
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupUpload
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthUpload
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthUpload        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowUpload          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupUpload = fmt.Errorf("proto: unexpected end of group")
)
